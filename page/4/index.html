<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Q-Quiet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="note">
<meta property="og:type" content="website">
<meta property="og:title" content="Q-Quiet">
<meta property="og:url" content="https://Q-Quiet.github.io/page/4/index.html">
<meta property="og:site_name" content="Q-Quiet">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Q-Quiet">
  
    <link rel="alternate" href="/atom.xml" title="Q-Quiet" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="shortcut icon" href="ban.jpeg" type="image/x-icon">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Q-Quiet</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">言语笑靥迎来情</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Q-Quiet.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-es6-7-函数的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/11/es6-7-函数的扩展/" class="article-date">
  <time datetime="2020-02-11T05:07:03.000Z" itemprop="datePublished">2020-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/11/es6-7-函数的扩展/">es6-7-函数的扩展</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h3 id="ES6-之前，不能直接为函数的参数指定默认值，只能采用变通的方法。"><a href="#ES6-之前，不能直接为函数的参数指定默认值，只能采用变通的方法。" class="headerlink" title="ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。"></a>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  y = y || <span class="string">'World'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。"><a href="#上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。" class="headerlink" title="上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。"></a>上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。</h3><h3 id="这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。"><a href="#这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。" class="headerlink" title="这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。"></a>这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。</h3><h3 id="上面代码的最后一行，-参数y等于空字符-，结果被改为默认值。"><a href="#上面代码的最后一行，-参数y等于空字符-，结果被改为默认值。" class="headerlink" title="上面代码的最后一行，==参数y等于空字符==，结果被改为默认值。"></a>上面代码的最后一行，==参数y等于空字符==，结果被改为默认值。</h3><h3 id="为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。"><a href="#为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。" class="headerlink" title="为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。"></a>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  y = <span class="string">'World'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="但是，ES6-允许为函数的参数设置默认值，即直接写在参数定义的后面。"><a href="#但是，ES6-允许为函数的参数设置默认值，即直接写在参数定义的后面。" class="headerlink" title="但是，ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。"></a>但是，ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<h3 id="除了简洁，ES6-的写法还有两个好处：阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。"><a href="#除了简洁，ES6-的写法还有两个好处：阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。" class="headerlink" title="除了简洁，ES6 的写法还有两个好处：阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。"></a>除了简洁，ES6 的写法还有两个好处：阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</h3><hr>
<blockquote>
<ol>
<li>参数变量是默认声明的，所以不能用let或const再次声明。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>使用参数默认值时，函数不能有同名参数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h3 id="上面代码中，参数p的默认值是x-1。这时，每次调用函数foo，都会重新计算x-1，而不是默认p等于-100。"><a href="#上面代码中，参数p的默认值是x-1。这时，每次调用函数foo，都会重新计算x-1，而不是默认p等于-100。" class="headerlink" title="上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。"></a>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</h3><hr>
<h1 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h1><h2 id="一-第一种"><a href="#一-第一种" class="headerlink" title="一. 第一种"></a>一. 第一种</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。"><a href="#上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。" class="headerlink" title="上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。"></a>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。</h3><blockquote>
<p>通过提供函数参数的默认值，就可以避免这种情况。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="二-第二种"><a href="#二-第二种" class="headerlink" title="二. 第二种"></a>二. 第二种</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// "GET"</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，双重默认值。"><a href="#上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，双重默认值。" class="headerlink" title="上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，双重默认值。"></a>上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，双重默认值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line"><span class="comment">// "GET"</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。"><a href="#上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。" class="headerlink" title="上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。"></a>上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。</h3><h3 id="作为练习，请问下面两种写法有什么差别？"><a href="#作为练习，请问下面两种写法有什么差别？" class="headerlink" title="作为练习，请问下面两种写法有什么差别？"></a>作为练习，请问下面两种写法有什么差别？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。"><a href="#上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。" class="headerlink" title="上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。"></a>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line">m1() <span class="comment">// [0, 0]</span></span><br><span class="line">m2() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h1><h3 id="如果非尾部的参数设置默认值，实际上这个参数是没法省略的。"><a href="#如果非尾部的参数设置默认值，实际上这个参数是没法省略的。" class="headerlink" title="如果非尾部的参数设置默认值，实际上这个参数是没法省略的。"></a>如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined])</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</p>
</blockquote>
<h3 id="如果传入undefined，将触发该参数等于默认值，null则没有这个效果。"><a href="#如果传入undefined，将触发该参数等于默认值，null则没有这个效果。" class="headerlink" title="如果传入undefined，将触发该参数等于默认值，null则没有这个效果。"></a>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span>, y = <span class="number">6</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 5 null</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h1><h3 id="指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。"><a href="#指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。" class="headerlink" title="指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。"></a>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="length属性的含义，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。"><a href="#length属性的含义，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。" class="headerlink" title="length属性的含义，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。"></a>length属性的含义，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。"><a href="#如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。" class="headerlink" title="如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。"></a>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h3 id="一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。"><a href="#一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。" class="headerlink" title="一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。"></a>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。</h3><blockquote>
<p>这种语法行为，在不设置参数默认值时，是不会出现的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。"><a href="#上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。" class="headerlink" title="上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。"></a>上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，函数f调用时，参数y-x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。"><a href="#上面代码中，函数f调用时，参数y-x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。" class="headerlink" title="上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。"></a>上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</h3><h3 id="如果此时，全局变量x不存在，就会报错。"><a href="#如果此时，全局变量x不存在，就会报错。" class="headerlink" title="如果此时，全局变量x不存在，就会报错。"></a>如果此时，全局变量x不存在，就会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="下面这样写，也会报错。"><a href="#下面这样写，也会报错。" class="headerlink" title="下面这样写，也会报错。"></a>下面这样写，也会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，参数x-x形成一个单独作用域。实际执行的是let-x-x，由于暂时性死区的原因，这行代码会报错”x-未定义“。"><a href="#上面代码中，参数x-x形成一个单独作用域。实际执行的是let-x-x，由于暂时性死区的原因，这行代码会报错”x-未定义“。" class="headerlink" title="上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。"></a>上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</h3><h3 id="如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。"><a href="#如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。" class="headerlink" title="如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。"></a>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'outer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = (</span>) =&gt; <span class="title">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// outer</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。"><a href="#上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。" class="headerlink" title="上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。"></a>上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。</h3><h3 id="如果写成下面这样，就会报错。"><a href="#如果写成下面这样，就会报错。" class="headerlink" title="如果写成下面这样，就会报错。"></a>如果写成下面这样，就会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = (</span>) =&gt; <span class="title">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。"><a href="#上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。" class="headerlink" title="上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。"></a>上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 3</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。"><a href="#上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。" class="headerlink" title="上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。"></a>上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</h3><h3 id="如果将var-x-3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。"><a href="#如果将var-x-3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。" class="headerlink" title="如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。"></a>如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h1><h3 id="尾调用（Tail-Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。"><a href="#尾调用（Tail-Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。" class="headerlink" title="尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。"></a>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。"><a href="#上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。" class="headerlink" title="上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。"></a>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</h3><h3 id="以下三种情况，都不属于尾调用。"><a href="#以下三种情况，都不属于尾调用。" class="headerlink" title="以下三种情况，都不属于尾调用。"></a>以下三种情况，都不属于尾调用。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。"><a href="#上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。" class="headerlink" title="上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。"></a>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。</h3><h3 id="情况二也属于调用后还有操作，即使写在一行内。"><a href="#情况二也属于调用后还有操作，即使写在一行内。" class="headerlink" title="情况二也属于调用后还有操作，即使写在一行内。"></a>情况二也属于调用后还有操作，即使写在一行内。</h3><h3 id="情况三等同于下面的代码。"><a href="#情况三等同于下面的代码。" class="headerlink" title="情况三等同于下面的代码。"></a>情况三等同于下面的代码。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="尾调用不一定出现在函数尾部，只要是最后一步操作即可。"><a href="#尾调用不一定出现在函数尾部，只要是最后一步操作即可。" class="headerlink" title="尾调用不一定出现在函数尾部，只要是最后一步操作即可。"></a>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。"><a href="#上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。" class="headerlink" title="上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。"></a>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</h3><blockquote>
<p>(不全)</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Q-Quiet.github.io/2020/02/11/es6-7-函数的扩展/" data-id="cklg8rx9f00262cup4r0j85ge" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es6-6-数值的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/10/es6-6-数值的扩展/" class="article-date">
  <time datetime="2020-02-10T02:28:54.000Z" itemprop="datePublished">2020-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/10/es6-6-数值的扩展/">es6-6-数值的扩展</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-二进制和八进制表示法"><a href="#1-二进制和八进制表示法" class="headerlink" title="1.二进制和八进制表示法"></a>1.二进制和八进制表示法</h1><h3 id="ES6-提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。"><a href="#ES6-提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。" class="headerlink" title="ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。"></a>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="从-ES5-开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6-进一步明确，要使用前缀0o表示。"><a href="#从-ES5-开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6-进一步明确，要使用前缀0o表示。" class="headerlink" title="从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。"></a>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure>
<h3 id="如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。"><a href="#如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。" class="headerlink" title="如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。"></a>如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'0b111'</span>)  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0o10'</span>)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-Number-isFinite-Number-isNaN"><a href="#2-Number-isFinite-Number-isNaN" class="headerlink" title="2.Number.isFinite(), Number.isNaN()"></a>2.Number.isFinite(), Number.isNaN()</h1><h3 id="ES6-在Number对象上，新提供了Number-isFinite-和Number-isNaN-两个方法。"><a href="#ES6-在Number对象上，新提供了Number-isFinite-和Number-isNaN-两个方法。" class="headerlink" title="ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。"></a>ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。</h3><h3 id="Number-isFinite-用来检查一个数值是否为有限的（finite），即不是Infinity。"><a href="#Number-isFinite-用来检查一个数值是否为有限的（finite），即不是Infinity。" class="headerlink" title="Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。"></a>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'foo'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'15'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果参数类型不是数值，Number.isFinite一律返回false。</p>
</blockquote>
<h3 id="Number-isNaN-用来检查一个值是否为NaN。"><a href="#Number-isNaN-用来检查一个值是否为NaN。" class="headerlink" title="Number.isNaN()用来检查一个值是否为NaN。"></a>Number.isNaN()用来检查一个值是否为NaN。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="string">'true'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="如果参数类型不是NaN，Number-isNaN一律返回false。"><a href="#如果参数类型不是NaN，Number-isNaN一律返回false。" class="headerlink" title="如果参数类型不是NaN，Number.isNaN一律返回false。"></a>如果参数类型不是NaN，Number.isNaN一律返回false。</h3><h3 id="它们与传统的全局方法isFinite-和isNaN-的区别在于，传统方法先调用Number-将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number-isFinite-对于非数值一律返回false-Number-isNaN-只有对于NaN才返回true，非NaN一律返回false。"><a href="#它们与传统的全局方法isFinite-和isNaN-的区别在于，传统方法先调用Number-将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number-isFinite-对于非数值一律返回false-Number-isNaN-只有对于NaN才返回true，非NaN一律返回false。" class="headerlink" title="它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。"></a>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">"25"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">"25"</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"NaN"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-Number-parseInt-Number-parseFloat"><a href="#3-Number-parseInt-Number-parseFloat" class="headerlink" title="3.Number.parseInt(), Number.parseFloat()"></a>3.Number.parseInt(), Number.parseFloat()</h1><h3 id="ES6-将全局方法parseInt-和parseFloat-，移植到Number对象上面，行为完全保持不变。"><a href="#ES6-将全局方法parseInt-和parseFloat-，移植到Number对象上面，行为完全保持不变。" class="headerlink" title="ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。"></a>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
<h3 id="这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。"><a href="#这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。" class="headerlink" title="这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。"></a>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</h3><blockquote>
<p>?????,全局性方法？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.parseInt === <span class="built_in">parseInt</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat === <span class="built_in">parseFloat</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h1 id="4-Number-isInteger-用来判断一个数值是否为整数"><a href="#4-Number-isInteger-用来判断一个数值是否为整数" class="headerlink" title="4.Number.isInteger()用来判断一个数值是否为整数"></a>4.Number.isInteger()用来判断一个数值是否为整数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="JavaScript-内部，整数和浮点数采用的是同样的储存方法，所以-25-和-25-0-被视为同一个值。"><a href="#JavaScript-内部，整数和浮点数采用的是同样的储存方法，所以-25-和-25-0-被视为同一个值。" class="headerlink" title="JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。"></a>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="如果参数不是数值，Number-isInteger返回false。"><a href="#如果参数不是数值，Number-isInteger返回false。" class="headerlink" title="如果参数不是数值，Number.isInteger返回false。"></a>如果参数不是数值，Number.isInteger返回false。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger() <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="注意，由于-JavaScript-采用-IEEE-754-标准，数值存储为64位双精度格式，数值精度最多可以达到-53-个二进制位（1-个隐藏位与-52-个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number-isInteger可能会误判。"><a href="#注意，由于-JavaScript-采用-IEEE-754-标准，数值存储为64位双精度格式，数值精度最多可以达到-53-个二进制位（1-个隐藏位与-52-个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number-isInteger可能会误判。" class="headerlink" title="注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。"></a>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，Number-isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。"><a href="#上面代码中，Number-isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。" class="headerlink" title="上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。"></a>上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。</h3><h3 id="类似的情况还有，如果一个数值的绝对值小于Number-MIN-VALUE（5E-324），即小于-JavaScript-能够分辨的最小值，会被自动转为-0。这时，Number-isInteger也会误判。"><a href="#类似的情况还有，如果一个数值的绝对值小于Number-MIN-VALUE（5E-324），即小于-JavaScript-能够分辨的最小值，会被自动转为-0。这时，Number-isInteger也会误判。" class="headerlink" title="类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。"></a>类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-324</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-325</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。"><a href="#上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。" class="headerlink" title="上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。"></a>上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。</h3><h3 id="总之，如果对数据精度的要求较高，不建议使用Number-isInteger-判断一个数值是否为整数。"><a href="#总之，如果对数据精度的要求较高，不建议使用Number-isInteger-判断一个数值是否为整数。" class="headerlink" title="总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。"></a>总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。</h3><hr>
<ol start="5">
<li><h1 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h1><h3 id="ES6-在Number对象上面，新增一个极小的常量Number-EPSILON。根据规格，它表示-1-与大于-1-的最小浮点数之间的差。"><a href="#ES6-在Number对象上面，新增一个极小的常量Number-EPSILON。根据规格，它表示-1-与大于-1-的最小浮点数之间的差。" class="headerlink" title="ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。"></a>ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</h3></li>
</ol>
<h3 id="对于-64-位浮点数来说，大于-1-的最小浮点数相当于二进制的1-00-001，小数点后面有连续-51-个零。这个值减去-1-之后，就等于-2-的-52-次方。"><a href="#对于-64-位浮点数来说，大于-1-的最小浮点数相当于二进制的1-00-001，小数点后面有连续-51-个零。这个值减去-1-之后，就等于-2-的-52-次方。" class="headerlink" title="对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。"></a>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-52</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// 2.220446049250313e-16</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// "0.00000000000000022204"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
</blockquote>
<h3 id="引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。"><a href="#引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。" class="headerlink" title="引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。"></a>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span></span><br><span class="line"><span class="comment">// 5.551115123125783e-17</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.551115123125783e-17</span>.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// '0.00000000000000005551'</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码解释了，为什么比较0-1-0-2与0-3得到的结果是false。"><a href="#上面代码解释了，为什么比较0-1-0-2与0-3得到的结果是false。" class="headerlink" title="上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。"></a>上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="Number-EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为-2-的-50-次方（即Number-EPSILON-Math-pow-2-2-），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。"><a href="#Number-EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为-2-的-50-次方（即Number-EPSILON-Math-pow-2-2-），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。" class="headerlink" title="Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。"></a>Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.551115123125783e-17</span> &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因此，Number.EPSILON的实质是一个可以接受的最小误差范围。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="上面的代码为浮点数运算，部署了一个误差检查函数。"><a href="#上面的代码为浮点数运算，部署了一个误差检查函数。" class="headerlink" title="上面的代码为浮点数运算，部署了一个误差检查函数。"></a>上面的代码为浮点数运算，部署了一个误差检查函数。</h3><hr>
<h1 id="6-安全整数和-Number-isSafeInteger"><a href="#6-安全整数和-Number-isSafeInteger" class="headerlink" title="6.安全整数和 Number.isSafeInteger()"></a>6.安全整数和 Number.isSafeInteger()</h1><h3 id="JavaScript-能够准确表示的整数范围在-2-53到2-53之间（不含两个端点），超过这个范围，无法精确表示这个值。"><a href="#JavaScript-能够准确表示的整数范围在-2-53到2-53之间（不含两个端点），超过这个范围，无法精确表示这个值。" class="headerlink" title="JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。"></a>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="number">9007199254740992</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，超出-2-的-53-次方之后，一个数就不精确了。"><a href="#上面代码中，超出-2-的-53-次方之后，一个数就不精确了。" class="headerlink" title="上面代码中，超出 2 的 53 次方之后，一个数就不精确了。"></a>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</h3><h3 id="ES6-引入了Number-MAX-SAFE-INTEGER和Number-MIN-SAFE-INTEGER这两个常量，用来表示这个范围的上下限。"><a href="#ES6-引入了Number-MAX-SAFE-INTEGER和Number-MIN-SAFE-INTEGER这两个常量，用来表示这个范围的上下限。" class="headerlink" title="ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。"></a>ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === <span class="number">-9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，可以看到-JavaScript-能够精确表示的极限。"><a href="#上面代码中，可以看到-JavaScript-能够精确表示的极限。" class="headerlink" title="上面代码中，可以看到 JavaScript 能够精确表示的极限。"></a>上面代码中，可以看到 JavaScript 能够精确表示的极限。</h3><h3 id="Number-isSafeInteger-则是用来判断一个整数是否落在这个范围之内。"><a href="#Number-isSafeInteger-则是用来判断一个整数是否落在这个范围之内。" class="headerlink" title="Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。"></a>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">1.2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740990</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740992</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。"><a href="#这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。" class="headerlink" title="这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。"></a>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> n === <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">Math</span>.round(n) === n &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</span><br><span class="line">    n &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。"><a href="#实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。" class="headerlink" title="实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。"></a>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="number">9007199254740993</span> - <span class="number">990</span></span><br><span class="line"><span class="comment">// 返回结果 9007199254740002</span></span><br><span class="line"><span class="comment">// 正确答案应该是 9007199254740003</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，9007199254740993不是一个安全整数，但是Number-isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。"><a href="#上面代码中，9007199254740993不是一个安全整数，但是Number-isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。" class="headerlink" title="上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。"></a>上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740993</span> === <span class="number">9007199254740992</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。"><a href="#所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。" class="headerlink" title="所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。"></a>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trusty</span> (<span class="params">left, right, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(left) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(right) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(result)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'Operation cannot be trusted!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trusty(<span class="number">9007199254740993</span>, <span class="number">990</span>, <span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// RangeError: Operation cannot be trusted!</span></span><br><span class="line"></span><br><span class="line">trusty(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="7-Math-对象的扩展"><a href="#7-Math-对象的扩展" class="headerlink" title="7.Math 对象的扩展"></a>7.Math 对象的扩展</h1><h3 id="ES6-在-Math-对象上新增了-17-个与数学相关的方法。所有这些方法都是静态方法，只能在-Math-对象上调用。"><a href="#ES6-在-Math-对象上新增了-17-个与数学相关的方法。所有这些方法都是静态方法，只能在-Math-对象上调用。" class="headerlink" title="ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。"></a>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</h3><h2 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h2><h3 id="Math-trunc方法用于去除一个数的小数部分，返回整数部分。"><a href="#Math-trunc方法用于去除一个数的小数部分，返回整数部分。" class="headerlink" title="Math.trunc方法用于去除一个数的小数部分，返回整数部分。"></a>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-0.1234</span>) <span class="comment">// -0</span></span><br></pre></td></tr></table></figure>
<h3 id="对于非数值，Math-trunc内部使用Number方法将其先转为数值。"><a href="#对于非数值，Math-trunc内部使用Number方法将其先转为数值。" class="headerlink" title="对于非数值，Math.trunc内部使用Number方法将其先转为数值。"></a>对于非数值，Math.trunc内部使用Number方法将其先转为数值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'123.456'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">true</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="对于空值和无法截取整数的值，返回NaN。"><a href="#对于空值和无法截取整数的值，返回NaN。" class="headerlink" title="对于空值和无法截取整数的值，返回NaN。"></a>对于空值和无法截取整数的值，返回NaN。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'foo'</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h3 id="对于没有部署这个方法的环境，可以用下面的代码模拟。"><a href="#对于没有部署这个方法的环境，可以用下面的代码模拟。" class="headerlink" title="对于没有部署这个方法的环境，可以用下面的代码模拟。"></a>对于没有部署这个方法的环境，可以用下面的代码模拟。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc = <span class="built_in">Math</span>.trunc || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(x) : <span class="built_in">Math</span>.floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Math.ceil() 函数返回大于或等于一个给定数字的最小整数。<br>Math.floor() 返回小于或等于一个给定数字的最大整数。</p>
</blockquote>
<hr>
<h2 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h2><h3 id="Math-sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。"><a href="#Math-sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。" class="headerlink" title="Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。"></a>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</h3><h3 id="它会返回五种值。"><a href="#它会返回五种值。" class="headerlink" title="它会返回五种值。"></a>它会返回五种值。</h3><h3 id="参数为正数，返回-1；"><a href="#参数为正数，返回-1；" class="headerlink" title="- 参数为正数，返回+1；"></a>- 参数为正数，返回+1；</h3><h3 id="参数为负数，返回-1；"><a href="#参数为负数，返回-1；" class="headerlink" title="- 参数为负数，返回-1；"></a>- 参数为负数，返回-1；</h3><h3 id="参数为-0，返回0；"><a href="#参数为-0，返回0；" class="headerlink" title="- 参数为 0，返回0；"></a>- 参数为 0，返回0；</h3><h3 id="参数为-0，返回-0"><a href="#参数为-0，返回-0" class="headerlink" title="- 参数为-0，返回-0;"></a>- 参数为-0，返回-0;</h3><h3 id="其他值，返回NaN。"><a href="#其他值，返回NaN。" class="headerlink" title="- 其他值，返回NaN。"></a>- 其他值，返回NaN。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">5</span>) <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>) <span class="comment">// +0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-0</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">NaN</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h3 id="如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。"><a href="#如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。" class="headerlink" title="如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。"></a>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="string">''</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">true</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">false</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">'9'</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">'foo'</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign()  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">undefined</span>)  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h3 id="对于没有部署这个方法的环境，可以用下面的代码模拟。-1"><a href="#对于没有部署这个方法的环境，可以用下面的代码模拟。-1" class="headerlink" title="对于没有部署这个方法的环境，可以用下面的代码模拟。"></a>对于没有部署这个方法的环境，可以用下面的代码模拟。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign = <span class="built_in">Math</span>.sign || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = +x; <span class="comment">// convert to a number</span></span><br><span class="line">  <span class="keyword">if</span> (x === <span class="number">0</span> || <span class="built_in">isNaN</span>(x)) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h2><h3 id="Math-cbrt方法用于计算一个数的立方根。"><a href="#Math-cbrt方法用于计算一个数的立方根。" class="headerlink" title="Math.cbrt方法用于计算一个数的立方根。"></a>Math.cbrt方法用于计算一个数的立方根。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">-1</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">1</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">2</span>)  <span class="comment">// 1.2599210498948734</span></span><br></pre></td></tr></table></figure>
<h3 id="对于非数值，Math-cbrt方法内部也是先使用Number方法将其转为数值。"><a href="#对于非数值，Math-cbrt方法内部也是先使用Number方法将其转为数值。" class="headerlink" title="对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。"></a>对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">'8'</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">'hello'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h3 id="对于没有部署这个方法的环境，可以用下面的代码模拟。-2"><a href="#对于没有部署这个方法的环境，可以用下面的代码模拟。-2" class="headerlink" title="对于没有部署这个方法的环境，可以用下面的代码模拟。"></a>对于没有部署这个方法的环境，可以用下面的代码模拟。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt = <span class="built_in">Math</span>.cbrt || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">Math</span>.pow(<span class="built_in">Math</span>.abs(x), <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h2><h3 id="Math-clz32-方法将参数转为-32-位无符号整数的形式，然后返回这个-32-位值里面有多少个前导-0。"><a href="#Math-clz32-方法将参数转为-32-位无符号整数的形式，然后返回这个-32-位值里面有多少个前导-0。" class="headerlink" title="Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。"></a>Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1000</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b01000000000000000000000000000000</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b00100000000000000000000000000000</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，0-的二进制形式全为-0，所以有-32-个前导-0；1-的二进制形式是0b1，只占-1-位，所以-32-位之中有-31-个前导-0；1000-的二进制形式是0b1111101000，一共有-10-位，所以-32-位之中有-22-个前导-0。"><a href="#上面代码中，0-的二进制形式全为-0，所以有-32-个前导-0；1-的二进制形式是0b1，只占-1-位，所以-32-位之中有-31-个前导-0；1000-的二进制形式是0b1111101000，一共有-10-位，所以-32-位之中有-22-个前导-0。" class="headerlink" title="上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。"></a>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。</h3><h3 id="clz32这个函数名就来自”count-leading-zero-bits-in-32-bit-binary-representation-of-a-number“（计算一个数的-32-位二进制形式的前导-0-的个数）的缩写。"><a href="#clz32这个函数名就来自”count-leading-zero-bits-in-32-bit-binary-representation-of-a-number“（计算一个数的-32-位二进制形式的前导-0-的个数）的缩写。" class="headerlink" title="clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。"></a>clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。</h3><h3 id="左移运算符（-lt-lt-）与Math-clz32方法直接相关。"><a href="#左移运算符（-lt-lt-）与Math-clz32方法直接相关。" class="headerlink" title="左移运算符（&lt;&lt;）与Math.clz32方法直接相关。"></a>左移运算符（&lt;&lt;）与Math.clz32方法直接相关。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// 29</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="对于小数，Math-clz32方法只考虑整数部分。"><a href="#对于小数，Math-clz32方法只考虑整数部分。" class="headerlink" title="对于小数，Math.clz32方法只考虑整数部分。"></a>对于小数，Math.clz32方法只考虑整数部分。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">3.2</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">3.9</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<h3 id="对于空值或其他类型的值，Math-clz32方法会将它们先转为数值，然后再计算。"><a href="#对于空值或其他类型的值，Math-clz32方法会将它们先转为数值，然后再计算。" class="headerlink" title="对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。"></a>对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32() <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">NaN</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">Infinity</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">null</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="string">'foo'</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32([]) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(&#123;&#125;) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">true</span>) <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h2><h3 id="Math-imul方法返回两个数以-32-位带符号整数形式相乘的结果，返回的也是一个-32-位的带符号整数。"><a href="#Math-imul方法返回两个数以-32-位带符号整数形式相乘的结果，返回的也是一个-32-位的带符号整数。" class="headerlink" title="Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。"></a>Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.imul(<span class="number">2</span>, <span class="number">4</span>)   <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(<span class="number">-1</span>, <span class="number">8</span>)  <span class="comment">// -8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(<span class="number">-2</span>, <span class="number">-2</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h3 id="如果只考虑最后-32-位，大多数情况下，Math-imul-a-b-与a-b的结果是相同的，即该方法等同于-a-b-0的效果（超过-32-位的部分溢出）。之所以需要部署这个方法，是因为-JavaScript-有精度限制，超过-2-的-53-次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math-imul方法可以返回正确的低位数值。"><a href="#如果只考虑最后-32-位，大多数情况下，Math-imul-a-b-与a-b的结果是相同的，即该方法等同于-a-b-0的效果（超过-32-位的部分溢出）。之所以需要部署这个方法，是因为-JavaScript-有精度限制，超过-2-的-53-次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math-imul方法可以返回正确的低位数值。" class="headerlink" title="如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a  b的结果是相同的，即该方法等同于(a  b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。"></a>如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a <em> b的结果是相同的，即该方法等同于(a </em> b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0x7fffffff</span> * <span class="number">0x7fffffff</span>)|<span class="number">0</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="上面这个乘法算式，返回结果为-0。但是由于这两个二进制数的最低位都是-1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是-1。这个错误就是因为它们的乘积超过了-2-的-53-次方，JavaScript-无法保存额外的精度，就把低位的值都变成了-0。Math-imul方法可以返回正确的值-1。"><a href="#上面这个乘法算式，返回结果为-0。但是由于这两个二进制数的最低位都是-1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是-1。这个错误就是因为它们的乘积超过了-2-的-53-次方，JavaScript-无法保存额外的精度，就把低位的值都变成了-0。Math-imul方法可以返回正确的值-1。" class="headerlink" title="上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。"></a>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.imul(<span class="number">0x7fffffff</span>, <span class="number">0x7fffffff</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h2><h3 id="Math-fround方法返回一个数的32位单精度浮点数形式。"><a href="#Math-fround方法返回一个数的32位单精度浮点数形式。" class="headerlink" title="Math.fround方法返回一个数的32位单精度浮点数形式。"></a>Math.fround方法返回一个数的32位单精度浮点数形式。</h3><h3 id="对于32位单精度格式来说，数值精度是24个二进制位（1-位隐藏位与-23-位有效位），所以对于-224-至-224-之间的整数（不含两个端点），返回结果与参数本身一致。"><a href="#对于32位单精度格式来说，数值精度是24个二进制位（1-位隐藏位与-23-位有效位），所以对于-224-至-224-之间的整数（不含两个端点），返回结果与参数本身一致。" class="headerlink" title="对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。"></a>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0</span>)   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1</span>)   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span> - <span class="number">1</span>)   <span class="comment">// 16777215</span></span><br></pre></td></tr></table></figure>
<h3 id="如果参数的绝对值大于-224，返回的结果便开始丢失精度。"><a href="#如果参数的绝对值大于-224，返回的结果便开始丢失精度。" class="headerlink" title="如果参数的绝对值大于 224，返回的结果便开始丢失精度。"></a>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span>)       <span class="comment">// 16777216</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span> + <span class="number">1</span>)   <span class="comment">// 16777216</span></span><br></pre></td></tr></table></figure>
<h3 id="Math-fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。"><a href="#Math-fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。" class="headerlink" title="Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。"></a>Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未丢失有效精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.125</span>) <span class="comment">// 1.125</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">7.25</span>)  <span class="comment">// 7.25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 丢失精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.3</span>)   <span class="comment">// 0.30000001192092896</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.7</span>)   <span class="comment">// 0.699999988079071</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.0000000123</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="对于-NaN-和-Infinity，此方法返回原值。对于其它类型的非数值，Math-fround-方法会先将其转为数值，再返回单精度浮点数。"><a href="#对于-NaN-和-Infinity，此方法返回原值。对于其它类型的非数值，Math-fround-方法会先将其转为数值，再返回单精度浮点数。" class="headerlink" title="对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。"></a>对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">NaN</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">Infinity</span>) <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="string">'5'</span>)      <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">true</span>)     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">null</span>)     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround([])       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(&#123;&#125;)       <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h3 id="对于没有部署这个方法的环境，可以用下面的代码模拟。-3"><a href="#对于没有部署这个方法的环境，可以用下面的代码模拟。-3" class="headerlink" title="对于没有部署这个方法的环境，可以用下面的代码模拟。"></a>对于没有部署这个方法的环境，可以用下面的代码模拟。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround = <span class="built_in">Math</span>.fround || <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Float32Array</span>([x])[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h2><h3 id="Math-hypot方法返回所有参数的平方和的平方根。"><a href="#Math-hypot方法返回所有参数的平方和的平方根。" class="headerlink" title="Math.hypot方法返回所有参数的平方和的平方根。"></a>Math.hypot方法返回所有参数的平方和的平方根。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot();            <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="literal">NaN</span>);         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'foo'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'5'</span>);   <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">-3</span>);          <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，3-的平方加上-4-的平方，等于-5-的平方。"><a href="#上面代码中，3-的平方加上-4-的平方，等于-5-的平方。" class="headerlink" title="上面代码中，3 的平方加上 4 的平方，等于 5 的平方。"></a>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</h3><h3 id="如果参数不是数值，Math-hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回-NaN。"><a href="#如果参数不是数值，Math-hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回-NaN。" class="headerlink" title="如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。"></a>如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</h3><hr>
<h1 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h1><h3 id="ES6-新增了-4-个对数相关方法。"><a href="#ES6-新增了-4-个对数相关方法。" class="headerlink" title="ES6 新增了 4 个对数相关方法。"></a>ES6 新增了 4 个对数相关方法。</h3><h2 id="（1）-Math-expm1"><a href="#（1）-Math-expm1" class="headerlink" title="（1） Math.expm1()"></a>（1） Math.expm1()</h2><h3 id="Math-expm1-x-返回-ex-1，即Math-exp-x-1。"><a href="#Math-expm1-x-返回-ex-1，即Math-exp-x-1。" class="headerlink" title="Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。"></a>Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">-1</span>) <span class="comment">// -0.6321205588285577</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">1</span>)  <span class="comment">// 1.718281828459045</span></span><br></pre></td></tr></table></figure>
<h3 id="对于没有部署这个方法的环境，可以用下面的代码模拟。-4"><a href="#对于没有部署这个方法的环境，可以用下面的代码模拟。-4" class="headerlink" title="对于没有部署这个方法的环境，可以用下面的代码模拟。"></a>对于没有部署这个方法的环境，可以用下面的代码模拟。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1 = <span class="built_in">Math</span>.expm1 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x) - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="（2）Math-log1p"><a href="#（2）Math-log1p" class="headerlink" title="（2）Math.log1p()"></a>（2）Math.log1p()</h2><h3 id="Math-log1p-x-方法返回1-x的自然对数，即Math-log-1-x-。如果x小于-1，返回NaN。"><a href="#Math-log1p-x-方法返回1-x的自然对数，即Math-log-1-x-。如果x小于-1，返回NaN。" class="headerlink" title="Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。"></a>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">1</span>)  <span class="comment">// 0.6931471805599453</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">-1</span>) <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">-2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h3 id="对于没有部署这个方法的环境，可以用下面的代码模拟。-5"><a href="#对于没有部署这个方法的环境，可以用下面的代码模拟。-5" class="headerlink" title="对于没有部署这个方法的环境，可以用下面的代码模拟。"></a>对于没有部署这个方法的环境，可以用下面的代码模拟。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p = <span class="built_in">Math</span>.log1p || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(<span class="number">1</span> + x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="（3）Math-log10"><a href="#（3）Math-log10" class="headerlink" title="（3）Math.log10()"></a>（3）Math.log10()</h2><h3 id="Math-log10-x-返回以-10-为底的x的对数。如果x小于-0，则返回-NaN。"><a href="#Math-log10-x-返回以-10-为底的x的对数。如果x小于-0，则返回-NaN。" class="headerlink" title="Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。"></a>Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10(<span class="number">2</span>)      <span class="comment">// 0.3010299956639812</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">1</span>)      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">0</span>)      <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">-2</span>)     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">100000</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="对于没有部署这个方法的环境，可以用下面的代码模拟。-6"><a href="#对于没有部署这个方法的环境，可以用下面的代码模拟。-6" class="headerlink" title="对于没有部署这个方法的环境，可以用下面的代码模拟。"></a>对于没有部署这个方法的环境，可以用下面的代码模拟。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10 = <span class="built_in">Math</span>.log10 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="（4）Math-log2"><a href="#（4）Math-log2" class="headerlink" title="（4）Math.log2()"></a>（4）Math.log2()</h2><h3 id="Math-log2-x-返回以-2-为底的x的对数。如果x小于-0，则返回-NaN。"><a href="#Math-log2-x-返回以-2-为底的x的对数。如果x小于-0，则返回-NaN。" class="headerlink" title="Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。"></a>Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2(<span class="number">3</span>)       <span class="comment">// 1.584962500721156</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">2</span>)       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span>)       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">0</span>)       <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">-2</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1024</span>)    <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
<h3 id="对于没有部署这个方法的环境，可以用下面的代码模拟。-7"><a href="#对于没有部署这个方法的环境，可以用下面的代码模拟。-7" class="headerlink" title="对于没有部署这个方法的环境，可以用下面的代码模拟。"></a>对于没有部署这个方法的环境，可以用下面的代码模拟。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2 = <span class="built_in">Math</span>.log2 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="双曲函数方法"><a href="#双曲函数方法" class="headerlink" title="双曲函数方法"></a>双曲函数方法</h1><h3 id="ES6-新增了-6-个双曲函数方法。"><a href="#ES6-新增了-6-个双曲函数方法。" class="headerlink" title="ES6 新增了 6 个双曲函数方法。"></a>ES6 新增了 6 个双曲函数方法。</h3><h3 id="Math-sinh-x-返回x的双曲正弦（hyperbolic-sine）"><a href="#Math-sinh-x-返回x的双曲正弦（hyperbolic-sine）" class="headerlink" title="- Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）"></a>- Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）</h3><h3 id="Math-cosh-x-返回x的双曲余弦（hyperbolic-cosine）"><a href="#Math-cosh-x-返回x的双曲余弦（hyperbolic-cosine）" class="headerlink" title="- Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）"></a>- Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）</h3><h3 id="Math-tanh-x-返回x的双曲正切（hyperbolic-tangent）"><a href="#Math-tanh-x-返回x的双曲正切（hyperbolic-tangent）" class="headerlink" title="- Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）"></a>- Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）</h3><h3 id="Math-asinh-x-返回x的反双曲正弦（inverse-hyperbolic-sine）"><a href="#Math-asinh-x-返回x的反双曲正弦（inverse-hyperbolic-sine）" class="headerlink" title="- Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）"></a>- Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）</h3><h3 id="Math-acosh-x-返回x的反双曲余弦（inverse-hyperbolic-cosine）"><a href="#Math-acosh-x-返回x的反双曲余弦（inverse-hyperbolic-cosine）" class="headerlink" title="- Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）"></a>- Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）</h3><h3 id="Math-atanh-x-返回x的反双曲正切（inverse-hyperbolic-tangent）"><a href="#Math-atanh-x-返回x的反双曲正切（inverse-hyperbolic-tangent）" class="headerlink" title="- Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）"></a>- Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</h3><hr>
<h1 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h1><h3 id="ES2016-新增了一个指数运算符（-）。"><a href="#ES2016-新增了一个指数运算符（-）。" class="headerlink" title="ES2016 新增了一个指数运算符（**）。"></a>ES2016 新增了一个指数运算符（**）。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h3 id="这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。"><a href="#这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。" class="headerlink" title="这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。"></a>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，首先计算的是第二个指数运算符，而不是第一个。"><a href="#上面代码中，首先计算的是第二个指数运算符，而不是第一个。" class="headerlink" title="上面代码中，首先计算的是第二个指数运算符，而不是第一个。"></a>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</h3><h3 id="指数运算符可以与等号结合，形成一个新的赋值运算符（-）。"><a href="#指数运算符可以与等号结合，形成一个新的赋值运算符（-）。" class="headerlink" title="指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。"></a>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1.5</span>;</span><br><span class="line">a **= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 等同于 a = a * a;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line">b **= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 等同于 b = b * b * b;</span></span><br></pre></td></tr></table></figure>
<h3 id="注意，V8-引擎的指数运算符与Math-pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。"><a href="#注意，V8-引擎的指数运算符与Math-pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。" class="headerlink" title="注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。"></a>注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">99</span>, <span class="number">99</span>)</span><br><span class="line"><span class="comment">// 3.697296376497263e+197</span></span><br><span class="line"></span><br><span class="line"><span class="number">99</span> ** <span class="number">99</span></span><br><span class="line"><span class="comment">// 3.697296376497268e+197</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，两个运算结果的最后一位有效数字是有差异的。"><a href="#上面代码中，两个运算结果的最后一位有效数字是有差异的。" class="headerlink" title="上面代码中，两个运算结果的最后一位有效数字是有差异的。"></a>上面代码中，两个运算结果的最后一位有效数字是有差异的。</h3><hr>
<h1 id="BigInt-数据类型"><a href="#BigInt-数据类型" class="headerlink" title="BigInt 数据类型"></a>BigInt 数据类型</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="JavaScript-所有数字都保存成-64-位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到-53-个二进制位（相当于-16-个十进制位），大于这个范围的整数，JavaScript-是无法精确表示的，这使得-JavaScript-不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript-无法表示，会返回Infinity。"><a href="#JavaScript-所有数字都保存成-64-位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到-53-个二进制位（相当于-16-个十进制位），大于这个范围的整数，JavaScript-是无法精确表示的，这使得-JavaScript-不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript-无法表示，会返回Infinity。" class="headerlink" title="JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。"></a>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<h3 id="ES2020-引入了一种新的数据类型-BigInt（大整数），来解决这个问题。BigInt-只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。"><a href="#ES2020-引入了一种新的数据类型-BigInt（大整数），来解决这个问题。BigInt-只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。" class="headerlink" title="ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。"></a>ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2172141653</span>n;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15346349309</span>n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 可以保持精度</span></span><br><span class="line">a * b <span class="comment">// 33334444555566667777n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通整数无法保持精度</span></span><br><span class="line"><span class="built_in">Number</span>(a) * <span class="built_in">Number</span>(b) <span class="comment">// 33334444555566670000</span></span><br></pre></td></tr></table></figure>
<h3 id="为了与-Number-类型区别，BigInt-类型的数据必须添加后缀n。"><a href="#为了与-Number-类型区别，BigInt-类型的数据必须添加后缀n。" class="headerlink" title="为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。"></a>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234</span> <span class="comment">// 普通整数</span></span><br><span class="line"><span class="number">1234</span>n <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1</span>n + <span class="number">2</span>n <span class="comment">// 3n</span></span><br></pre></td></tr></table></figure>
<h3 id="BigInt-同样可以使用各种进制表示，都要加上后缀n。"><a href="#BigInt-同样可以使用各种进制表示，都要加上后缀n。" class="headerlink" title="BigInt 同样可以使用各种进制表示，都要加上后缀n。"></a>BigInt 同样可以使用各种进制表示，都要加上后缀n。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b1101</span>n <span class="comment">// 二进制</span></span><br><span class="line"><span class="number">0o777</span>n <span class="comment">// 八进制</span></span><br><span class="line"><span class="number">0xFF</span>n <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>
<h3 id="BigInt-与普通整数是两种值，它们之间并不相等。"><a href="#BigInt-与普通整数是两种值，它们之间并不相等。" class="headerlink" title="BigInt 与普通整数是两种值，它们之间并不相等。"></a>BigInt 与普通整数是两种值，它们之间并不相等。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span>n === <span class="number">42</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="typeof运算符对于-BigInt-类型的数据返回bigint。"><a href="#typeof运算符对于-BigInt-类型的数据返回bigint。" class="headerlink" title="typeof运算符对于 BigInt 类型的数据返回bigint。"></a>typeof运算符对于 BigInt 类型的数据返回bigint。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>n <span class="comment">// 'bigint'</span></span><br></pre></td></tr></table></figure>
<h3 id="BigInt-可以使用负号（-），但是不能使用正号（-），因为会与-asm-js-冲突。"><a href="#BigInt-可以使用负号（-），但是不能使用正号（-），因为会与-asm-js-冲突。" class="headerlink" title="BigInt 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。"></a>BigInt 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-42</span>n <span class="comment">// 正确</span></span><br><span class="line">+<span class="number">42</span>n <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="JavaScript-以前不能计算70的阶乘（即70-），因为超出了可以表示的精度。"><a href="#JavaScript-以前不能计算70的阶乘（即70-），因为超出了可以表示的精度。" class="headerlink" title="JavaScript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。"></a>JavaScript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">70</span>; i++) &#123;</span><br><span class="line">  p *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// 1.197857166996989e+100</span></span><br></pre></td></tr></table></figure>
<h3 id="现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。"><a href="#现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。" class="headerlink" title="现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。"></a>现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="number">1</span>n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>n; i &lt;= <span class="number">70</span>n; i++) &#123;</span><br><span class="line">  p *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// 11978571...00000000n</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="BigInt-对象"><a href="#BigInt-对象" class="headerlink" title="BigInt 对象"></a>BigInt 对象</h2><h3 id="JavaScript-原生提供BigInt对象，可以用作构造函数生成-BigInt-类型的数值。转换规则基本与Number-一致，将其他类型的值转为-BigInt。"><a href="#JavaScript-原生提供BigInt对象，可以用作构造函数生成-BigInt-类型的数值。转换规则基本与Number-一致，将其他类型的值转为-BigInt。" class="headerlink" title="JavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。"></a>JavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigInt(<span class="number">123</span>) <span class="comment">// 123n</span></span><br><span class="line">BigInt(<span class="string">'123'</span>) <span class="comment">// 123n</span></span><br><span class="line">BigInt(<span class="literal">false</span>) <span class="comment">// 0n</span></span><br><span class="line">BigInt(<span class="literal">true</span>) <span class="comment">// 1n</span></span><br></pre></td></tr></table></figure>
<h3 id="BigInt-构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。"><a href="#BigInt-构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。" class="headerlink" title="BigInt()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。"></a>BigInt()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BigInt() <span class="comment">// TypeError</span></span><br><span class="line">BigInt(<span class="literal">undefined</span>) <span class="comment">//TypeError</span></span><br><span class="line">BigInt(<span class="literal">null</span>) <span class="comment">// TypeError</span></span><br><span class="line">BigInt(<span class="string">'123n'</span>) <span class="comment">// SyntaxError</span></span><br><span class="line">BigInt(<span class="string">'abc'</span>) <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，尤其值得注意字符串123n无法解析成-Number-类型，所以会报错。"><a href="#上面代码中，尤其值得注意字符串123n无法解析成-Number-类型，所以会报错。" class="headerlink" title="上面代码中，尤其值得注意字符串123n无法解析成 Number 类型，所以会报错。"></a>上面代码中，尤其值得注意字符串123n无法解析成 Number 类型，所以会报错。</h3><h3 id="参数如果是小数，也会报错。"><a href="#参数如果是小数，也会报错。" class="headerlink" title="参数如果是小数，也会报错。"></a>参数如果是小数，也会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInt(<span class="number">1.5</span>) <span class="comment">// RangeError</span></span><br><span class="line">BigInt(<span class="string">'1.5'</span>) <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<h3 id="BigInt-对象继承了-Object-对象的两个实例方法。"><a href="#BigInt-对象继承了-Object-对象的两个实例方法。" class="headerlink" title="BigInt 对象继承了 Object 对象的两个实例方法。"></a>BigInt 对象继承了 Object 对象的两个实例方法。</h3><h3 id="BigInt-prototype-toString"><a href="#BigInt-prototype-toString" class="headerlink" title="- BigInt.prototype.toString()"></a>- BigInt.prototype.toString()</h3><h3 id="BigInt-prototype-valueOf"><a href="#BigInt-prototype-valueOf" class="headerlink" title="- BigInt.prototype.valueOf()"></a>- BigInt.prototype.valueOf()</h3><h3 id="它还继承了-Number-对象的一个实例方法。"><a href="#它还继承了-Number-对象的一个实例方法。" class="headerlink" title="它还继承了 Number 对象的一个实例方法。"></a>它还继承了 Number 对象的一个实例方法。</h3><h3 id="BigInt-prototype-toLocaleString"><a href="#BigInt-prototype-toLocaleString" class="headerlink" title="- BigInt.prototype.toLocaleString()"></a>- BigInt.prototype.toLocaleString()</h3><h3 id="此外，还提供了三个静态方法。"><a href="#此外，还提供了三个静态方法。" class="headerlink" title="此外，还提供了三个静态方法。"></a>此外，还提供了三个静态方法。</h3><h3 id="BigInt-asUintN-width-BigInt-：-给定的-BigInt-转为-0-到-2width-1-之间对应的值。"><a href="#BigInt-asUintN-width-BigInt-：-给定的-BigInt-转为-0-到-2width-1-之间对应的值。" class="headerlink" title="- BigInt.asUintN(width, BigInt)： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。"></a>- BigInt.asUintN(width, BigInt)： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。</h3><h3 id="BigInt-asIntN-width-BigInt-：给定的-BigInt-转为-2width-1-到-2width-1-1-之间对应的值。"><a href="#BigInt-asIntN-width-BigInt-：给定的-BigInt-转为-2width-1-到-2width-1-1-之间对应的值。" class="headerlink" title="- BigInt.asIntN(width, BigInt)：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。"></a>- BigInt.asIntN(width, BigInt)：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。</h3><h3 id="BigInt-parseInt-string-radix-：近似于Number-parseInt-，将一个字符串转换成指定进制的-BigInt。"><a href="#BigInt-parseInt-string-radix-：近似于Number-parseInt-，将一个字符串转换成指定进制的-BigInt。" class="headerlink" title="- BigInt.parseInt(string[, radix])：近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。"></a>- BigInt.parseInt(string[, radix])：近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="number">2</span>n ** (<span class="number">64</span>n - <span class="number">1</span>n) - <span class="number">1</span>n;</span><br><span class="line"></span><br><span class="line">BigInt.asIntN(<span class="number">64</span>, max)</span><br><span class="line"><span class="comment">// 9223372036854775807n</span></span><br><span class="line">BigInt.asIntN(<span class="number">64</span>, max + <span class="number">1</span>n)</span><br><span class="line"><span class="comment">// -9223372036854775808n</span></span><br><span class="line">BigInt.asUintN(<span class="number">64</span>, max + <span class="number">1</span>n)</span><br><span class="line"><span class="comment">// 9223372036854775808n</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，max是64位带符号的-BigInt-所能表示的最大值。如果对这个值加1n，BigInt-asIntN-将会返回一个负值，因为这时新增的一位将被解释为符号位。而BigInt-asUintN-方法由于不存在符号位，所以可以正确返回结果。"><a href="#上面代码中，max是64位带符号的-BigInt-所能表示的最大值。如果对这个值加1n，BigInt-asIntN-将会返回一个负值，因为这时新增的一位将被解释为符号位。而BigInt-asUintN-方法由于不存在符号位，所以可以正确返回结果。" class="headerlink" title="上面代码中，max是64位带符号的 BigInt 所能表示的最大值。如果对这个值加1n，BigInt.asIntN()将会返回一个负值，因为这时新增的一位将被解释为符号位。而BigInt.asUintN()方法由于不存在符号位，所以可以正确返回结果。"></a>上面代码中，max是64位带符号的 BigInt 所能表示的最大值。如果对这个值加1n，BigInt.asIntN()将会返回一个负值，因为这时新增的一位将被解释为符号位。而BigInt.asUintN()方法由于不存在符号位，所以可以正确返回结果。</h3><h3 id="如果BigInt-asIntN-和BigInt-asUintN-指定的位数，小于数值本身的位数，那么头部的位将被舍弃。"><a href="#如果BigInt-asIntN-和BigInt-asUintN-指定的位数，小于数值本身的位数，那么头部的位将被舍弃。" class="headerlink" title="如果BigInt.asIntN()和BigInt.asUintN()指定的位数，小于数值本身的位数，那么头部的位将被舍弃。"></a>如果BigInt.asIntN()和BigInt.asUintN()指定的位数，小于数值本身的位数，那么头部的位将被舍弃。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="number">2</span>n ** (<span class="number">64</span>n - <span class="number">1</span>n) - <span class="number">1</span>n;</span><br><span class="line"></span><br><span class="line">BigInt.asIntN(<span class="number">32</span>, max) <span class="comment">// -1n</span></span><br><span class="line">BigInt.asUintN(<span class="number">32</span>, max) <span class="comment">// 4294967295n</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，max是一个64位的-BigInt，如果转为32位，前面的32位都会被舍弃。"><a href="#上面代码中，max是一个64位的-BigInt，如果转为32位，前面的32位都会被舍弃。" class="headerlink" title="上面代码中，max是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。"></a>上面代码中，max是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。</h3><h3 id="下面是BigInt-parseInt-的例子。"><a href="#下面是BigInt-parseInt-的例子。" class="headerlink" title="下面是BigInt.parseInt()的例子。"></a>下面是BigInt.parseInt()的例子。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.parseInt() 与 BigInt.parseInt() 的对比</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">'9007199254740993'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line">BigInt.parseInt(<span class="string">'9007199254740993'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 9007199254740993n</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，由于有效数字超出了最大限度，Number-parseInt方法返回的结果是不精确的，而BigInt-parseInt方法正确返回了对应的-BigInt。"><a href="#上面代码中，由于有效数字超出了最大限度，Number-parseInt方法返回的结果是不精确的，而BigInt-parseInt方法正确返回了对应的-BigInt。" class="headerlink" title="上面代码中，由于有效数字超出了最大限度，Number.parseInt方法返回的结果是不精确的，而BigInt.parseInt方法正确返回了对应的 BigInt。"></a>上面代码中，由于有效数字超出了最大限度，Number.parseInt方法返回的结果是不精确的，而BigInt.parseInt方法正确返回了对应的 BigInt。</h3><h3 id="对于二进制数组，BigInt-新增了两个类型BigUint64Array和BigInt64Array，这两种数据类型返回的都是64位-BigInt。DataView对象的实例方法DataView-prototype-getBigInt64-和DataView-prototype-getBigUint64-，返回的也是-BigInt。"><a href="#对于二进制数组，BigInt-新增了两个类型BigUint64Array和BigInt64Array，这两种数据类型返回的都是64位-BigInt。DataView对象的实例方法DataView-prototype-getBigInt64-和DataView-prototype-getBigUint64-，返回的也是-BigInt。" class="headerlink" title="对于二进制数组，BigInt 新增了两个类型BigUint64Array和BigInt64Array，这两种数据类型返回的都是64位 BigInt。DataView对象的实例方法DataView.prototype.getBigInt64()和DataView.prototype.getBigUint64()，返回的也是 BigInt。"></a>对于二进制数组，BigInt 新增了两个类型BigUint64Array和BigInt64Array，这两种数据类型返回的都是64位 BigInt。DataView对象的实例方法DataView.prototype.getBigInt64()和DataView.prototype.getBigUint64()，返回的也是 BigInt。</h3><hr>
<h1 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h1><h3 id="可以使用Boolean-、Number-和String-这三个方法，将-BigInt-可以转为布尔值、数值和字符串类型。"><a href="#可以使用Boolean-、Number-和String-这三个方法，将-BigInt-可以转为布尔值、数值和字符串类型。" class="headerlink" title="可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。"></a>可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>n) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>n) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">1</span>n)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">1</span>n)  <span class="comment">// "1"</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，注意最后一个例子，转为字符串时后缀n会消失。"><a href="#上面代码中，注意最后一个例子，转为字符串时后缀n会消失。" class="headerlink" title="上面代码中，注意最后一个例子，转为字符串时后缀n会消失。"></a>上面代码中，注意最后一个例子，转为字符串时后缀n会消失。</h3><h3 id="另外，取反运算符（-）也可以将-BigInt-转为布尔值。"><a href="#另外，取反运算符（-）也可以将-BigInt-转为布尔值。" class="headerlink" title="另外，取反运算符（!）也可以将 BigInt 转为布尔值。"></a>另外，取反运算符（!）也可以将 BigInt 转为布尔值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="number">0</span>n <span class="comment">// true</span></span><br><span class="line">!<span class="number">1</span>n <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><h3 id="数学运算方面，BigInt-类型的-、-、-和-这四个二元运算符，与-Number-类型的行为一致。除法运算-会舍去小数部分，返回一个整数。"><a href="#数学运算方面，BigInt-类型的-、-、-和-这四个二元运算符，与-Number-类型的行为一致。除法运算-会舍去小数部分，返回一个整数。" class="headerlink" title="数学运算方面，BigInt 类型的+、-、*和**这四个二元运算符，与 Number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。"></a>数学运算方面，BigInt 类型的+、-、*和**这四个二元运算符，与 Number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>n / <span class="number">5</span>n</span><br><span class="line"><span class="comment">// 1n</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。</p>
</blockquote>
<h3 id="不带符号的右移位运算符-gt-gt-gt"><a href="#不带符号的右移位运算符-gt-gt-gt" class="headerlink" title="- 不带符号的右移位运算符&gt;&gt;&gt;"></a>- 不带符号的右移位运算符&gt;&gt;&gt;</h3><h3 id="一元的求正运算符"><a href="#一元的求正运算符" class="headerlink" title="- 一元的求正运算符+"></a>- 一元的求正运算符+</h3><h3 id="上面两个运算符用在-BigInt-会报错。前者是因为-gt-gt-gt-运算符是不带符号的，但是-BigInt-总是带有符号的，导致该运算无意义，完全等同于右移运算符-gt-gt-。后者是因为一元运算符-在-asm-js-里面总是返回-Number-类型，为了不破坏-asm-js-就规定-1n会报错。"><a href="#上面两个运算符用在-BigInt-会报错。前者是因为-gt-gt-gt-运算符是不带符号的，但是-BigInt-总是带有符号的，导致该运算无意义，完全等同于右移运算符-gt-gt-。后者是因为一元运算符-在-asm-js-里面总是返回-Number-类型，为了不破坏-asm-js-就规定-1n会报错。" class="headerlink" title="上面两个运算符用在 BigInt 会报错。前者是因为&gt;&gt;&gt;运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符&gt;&gt;。后者是因为一元运算符+在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定+1n会报错。"></a>上面两个运算符用在 BigInt 会报错。前者是因为&gt;&gt;&gt;运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符&gt;&gt;。后者是因为一元运算符+在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定+1n会报错。</h3><h3 id="BigInt-不能与普通数值进行混合运算。"><a href="#BigInt-不能与普通数值进行混合运算。" class="headerlink" title="BigInt 不能与普通数值进行混合运算。"></a>BigInt 不能与普通数值进行混合运算。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>n + <span class="number">1.3</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码报错是因为无论返回的是-BigInt-或-Number，都会导致丢失精度信息。比如-2n-53n-1n-0-5这个表达式，如果返回-BigInt-类型，0-5这个小数部分会丢失；如果返回-Number-类型，有效精度只能保持-53-位，导致精度下降。"><a href="#上面代码报错是因为无论返回的是-BigInt-或-Number，都会导致丢失精度信息。比如-2n-53n-1n-0-5这个表达式，如果返回-BigInt-类型，0-5这个小数部分会丢失；如果返回-Number-类型，有效精度只能保持-53-位，导致精度下降。" class="headerlink" title="上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如(2n**53n + 1n) + 0.5这个表达式，如果返回 BigInt 类型，0.5这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。"></a>上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如(2n**53n + 1n) + 0.5这个表达式，如果返回 BigInt 类型，0.5这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。</h3><h3 id="同样的原因，如果一个标准库函数的参数预期是-Number-类型，但是得到的是一个-BigInt，就会报错。"><a href="#同样的原因，如果一个标准库函数的参数预期是-Number-类型，但是得到的是一个-BigInt，就会报错。" class="headerlink" title="同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。"></a>同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">Math.sqrt(4n) // 报错</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">Math.sqrt(Number(4n)) // 2</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，Math-sqrt的参数预期是-Number-类型，如果是-BigInt-就会报错，必须先用Number方法转一下类型，才能进行计算。"><a href="#上面代码中，Math-sqrt的参数预期是-Number-类型，如果是-BigInt-就会报错，必须先用Number方法转一下类型，才能进行计算。" class="headerlink" title="上面代码中，Math.sqrt的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用Number方法转一下类型，才能进行计算。"></a>上面代码中，Math.sqrt的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用Number方法转一下类型，才能进行计算。</h3><h3 id="asm-js-里面，-0跟在一个数值的后面会返回一个32位整数。根据不能与-Number-类型混合运算的规则，BigInt-如果与-0进行运算会报错。"><a href="#asm-js-里面，-0跟在一个数值的后面会返回一个32位整数。根据不能与-Number-类型混合运算的规则，BigInt-如果与-0进行运算会报错。" class="headerlink" title="asm.js 里面，|0跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与|0进行运算会报错。"></a>asm.js 里面，|0跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与|0进行运算会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>n | <span class="number">0</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h1><h3 id="BigInt-对应的布尔值，与-Number-类型一致，即0n会转为false，其他值转为true。"><a href="#BigInt-对应的布尔值，与-Number-类型一致，即0n会转为false，其他值转为true。" class="headerlink" title="BigInt 对应的布尔值，与 Number 类型一致，即0n会转为false，其他值转为true。"></a>BigInt 对应的布尔值，与 Number 类型一致，即0n会转为false，其他值转为true。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>n) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'if'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'else'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// else</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，0n对应false，所以会进入else子句。"><a href="#上面代码中，0n对应false，所以会进入else子句。" class="headerlink" title="上面代码中，0n对应false，所以会进入else子句。"></a>上面代码中，0n对应false，所以会进入else子句。</h3><h3 id="比较运算符（比如-gt-）和相等运算符（-）允许-BigInt-与其他类型的值混合计算，因为这样做不会损失精度。"><a href="#比较运算符（比如-gt-）和相等运算符（-）允许-BigInt-与其他类型的值混合计算，因为这样做不会损失精度。" class="headerlink" title="比较运算符（比如&gt;）和相等运算符（==）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。"></a>比较运算符（比如&gt;）和相等运算符（==）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>n &lt; <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>n &lt; <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>n == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>n == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>n === <span class="number">0</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="BigInt-与字符串混合运算时，会先转为字符串，再进行运算。"><a href="#BigInt-与字符串混合运算时，会先转为字符串，再进行运算。" class="headerlink" title="BigInt 与字符串混合运算时，会先转为字符串，再进行运算。"></a>BigInt 与字符串混合运算时，会先转为字符串，再进行运算。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span> + <span class="number">123</span>n <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://Q-Quiet.github.io/2020/02/10/es6-6-数值的扩展/" data-id="cklg8rxa2002h2cup2sgpqalm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es6-5-正则的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/07/es6-5-正则的扩展/" class="article-date">
  <time datetime="2020-02-07T13:11:15.000Z" itemprop="datePublished">2020-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/07/es6-5-正则的扩展/">es6-5-正则的扩展</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-RegExp-构造函数"><a href="#1-RegExp-构造函数" class="headerlink" title="1.RegExp 构造函数"></a>1.RegExp 构造函数</h1><h3 id="在-ES5-中，RegExp构造函数的参数有两种情况。"><a href="#在-ES5-中，RegExp构造函数的参数有两种情况。" class="headerlink" title="在 ES5 中，RegExp构造函数的参数有两种情况。"></a>在 ES5 中，RegExp构造函数的参数有两种情况。</h3><h3 id="第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。"><a href="#第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。" class="headerlink" title="第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。"></a>第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<h3 id="第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。"><a href="#第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。" class="headerlink" title="第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。"></a>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<h3 id="但是，ES5-不允许此时使用第二个参数添加修饰符，否则会报错。"><a href="#但是，ES5-不允许此时使用第二个参数添加修饰符，否则会报错。" class="headerlink" title="但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。"></a>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure>
<h3 id="ES6-改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。"><a href="#ES6-改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。" class="headerlink" title="ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。"></a>ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags</span><br><span class="line"><span class="comment">// "i"</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。"><a href="#上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。" class="headerlink" title="上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。"></a>上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。</h3><hr>
<h1 id="2-字符串的正则方法"><a href="#2-字符串的正则方法" class="headerlink" title="2.字符串的正则方法"></a>2.字符串的正则方法</h1><h3 id="字符串对象共有-4-个方法，可以使用正则表达式：match-、replace-、search-和split-。"><a href="#字符串对象共有-4-个方法，可以使用正则表达式：match-、replace-、search-和split-。" class="headerlink" title="字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。"></a>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。</h3><h3 id="ES6-将这-4-个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。"><a href="#ES6-将这-4-个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。" class="headerlink" title="ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。"></a>ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</h3><blockquote>
<ul>
<li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
</ul>
</blockquote>
<h1 id="3-u-修饰符"><a href="#3-u-修饰符" class="headerlink" title="3.u 修饰符"></a>3.u 修饰符</h1><h3 id="ES6-对正则表达式添加了u修饰符，含义为“Unicode-模式”，用来正确处理大于-uFFFF的-Unicode-字符。也就是说，会正确处理四个字节的-UTF-16-编码。"><a href="#ES6-对正则表达式添加了u修饰符，含义为“Unicode-模式”，用来正确处理大于-uFFFF的-Unicode-字符。也就是说，会正确处理四个字节的-UTF-16-编码。" class="headerlink" title="ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。"></a>ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，-uD83D-uDC2A是一个四个字节的-UTF-16-编码，代表一个字符。但是，ES5-不支持四个字节的-UTF-16-编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6-就会识别其为一个字符，所以第一行代码结果为false。"><a href="#上面代码中，-uD83D-uDC2A是一个四个字节的-UTF-16-编码，代表一个字符。但是，ES5-不支持四个字节的-UTF-16-编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6-就会识别其为一个字符，所以第一行代码结果为false。" class="headerlink" title="上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。"></a>上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。</h3><h3 id="一旦加上u修饰符号，就会修改下面这些正则表达式的行为。"><a href="#一旦加上u修饰符号，就会修改下面这些正则表达式的行为。" class="headerlink" title="一旦加上u修饰符号，就会修改下面这些正则表达式的行为。"></a>一旦加上u修饰符号，就会修改下面这些正则表达式的行为。</h3><blockquote>
<p>（1）点字符</p>
</blockquote>
<h3 id="点（-）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的-Unicode-字符，点字符不能识别，必须加上u修饰符。"><a href="#点（-）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的-Unicode-字符，点字符不能识别，必须加上u修饰符。" class="headerlink" title="点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。"></a>点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span>;</span><br><span class="line"></span><br><span class="line">/^.$/.test(s) <span class="comment">// flase</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。"><a href="#上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。" class="headerlink" title="上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。"></a>上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</h3><blockquote>
<p>（2）Unicode 字符表示法</p>
</blockquote>
<h3 id="ES6-新增了使用大括号表示-Unicode-字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。"><a href="#ES6-新增了使用大括号表示-Unicode-字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。" class="headerlink" title="ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。"></a>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line">/\u&#123;<span class="number">20</span>BB7&#125;/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码表示，如果不加u修饰符，正则表达式无法识别-u-61-这种表示法，只会认为这匹配-61-个连续的u。"><a href="#上面代码表示，如果不加u修饰符，正则表达式无法识别-u-61-这种表示法，只会认为这匹配-61-个连续的u。" class="headerlink" title="上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的u。"></a>上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的u。</h3><blockquote>
<p>（3）量词</p>
</blockquote>
<h3 id="使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的-Unicode-字符。"><a href="#使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的-Unicode-字符。" class="headerlink" title="使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。"></a>使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/a&#123;<span class="number">2</span>&#125;/.test(<span class="string">'aa'</span>) <span class="comment">// true</span></span><br><span class="line">/a&#123;<span class="number">2</span>&#125;/u.test(<span class="string">'aa'</span>) <span class="comment">// true</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// false</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/u.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>（4）预定义模式</p>
</blockquote>
<h3 id="u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的-Unicode-字符。"><a href="#u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的-Unicode-字符。" class="headerlink" title="u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。"></a>u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\S$/.test(<span class="string">'𠮷'</span>) <span class="comment">// false</span></span><br><span class="line">/^\S$/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码的-S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的-Unicode-字符。"><a href="#上面代码的-S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的-Unicode-字符。" class="headerlink" title="上面代码的\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。"></a>上面代码的\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。</h3><h3 id="利用这一点，可以写出一个正确返回字符串长度的函数。"><a href="#利用这一点，可以写出一个正确返回字符串长度的函数。" class="headerlink" title="利用这一点，可以写出一个正确返回字符串长度的函数。"></a>利用这一点，可以写出一个正确返回字符串长度的函数。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line">  <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷𠮷'</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 4</span></span><br><span class="line">codePointLength(s) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>（5）i 修饰符</p>
</blockquote>
<h3 id="有些-Unicode-字符的编码不同，但是字型很相近，比如，-u004B与-u212A都是大写的K。"><a href="#有些-Unicode-字符的编码不同，但是字型很相近，比如，-u004B与-u212A都是大写的K。" class="headerlink" title="有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。"></a>有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[a-z]/i.test(<span class="string">'\u212A'</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">'\u212A'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，不加u修饰符，就无法识别非规范的K字符。"><a href="#上面代码中，不加u修饰符，就无法识别非规范的K字符。" class="headerlink" title="上面代码中，不加u修饰符，就无法识别非规范的K字符。"></a>上面代码中，不加u修饰符，就无法识别非规范的K字符。</h3><blockquote>
<p>（6）转义</p>
</blockquote>
<h3 id="没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义-）无效，而在u模式会报错。"><a href="#没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义-）无效，而在u模式会报错。" class="headerlink" title="没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\,）无效，而在u模式会报错。"></a>没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\,）无效，而在u模式会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\,/ <span class="comment">// /\,/</span></span><br><span class="line">/\,/u <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。"><a href="#上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。" class="headerlink" title="上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。"></a>上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。</h3><hr>
<h1 id="4-RegExp-prototype-unicode-属性"><a href="#4-RegExp-prototype-unicode-属性" class="headerlink" title="4.RegExp.prototype.unicode 属性"></a>4.RegExp.prototype.unicode 属性</h1><h3 id="正则实例对象新增unicode属性，表示是否设置了u修饰符。"><a href="#正则实例对象新增unicode属性，表示是否设置了u修饰符。" class="headerlink" title="正则实例对象新增unicode属性，表示是否设置了u修饰符。"></a>正则实例对象新增unicode属性，表示是否设置了u修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">r1.unicode <span class="comment">// false</span></span><br><span class="line">r2.unicode <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。"><a href="#上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。" class="headerlink" title="上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。"></a>上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。</h3><hr>
<h1 id="5-y-修饰符"><a href="#5-y-修饰符" class="headerlink" title="5.y 修饰符"></a>5.y 修饰符</h1><h3 id="除了u修饰符，ES6-还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。"><a href="#除了u修饰符，ES6-还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。" class="headerlink" title="除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。"></a>除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</h3><h3 id="y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。"><a href="#y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。" class="headerlink" title="y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。"></a>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="第一次执行的时候，两者行为相同，剩余字符串都是-aa-a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。"><a href="#第一次执行的时候，两者行为相同，剩余字符串都是-aa-a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。" class="headerlink" title="第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。"></a>第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。</h3><h3 id="如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。"><a href="#如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。" class="headerlink" title="如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。"></a>如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a+_/y</span>;</span><br><span class="line"></span><br><span class="line">r.exec(s) <span class="comment">// ["aaa_"]</span></span><br><span class="line">r.exec(s) <span class="comment">// ["aa_"]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码每次匹配，都是从剩余字符串的头部开始。"><a href="#上面代码每次匹配，都是从剩余字符串的头部开始。" class="headerlink" title="上面代码每次匹配，都是从剩余字符串的头部开始。"></a>上面代码每次匹配，都是从剩余字符串的头部开始。</h3><h3 id="使用lastIndex属性，可以更好地说明y修饰符。"><a href="#使用lastIndex属性，可以更好地说明y修饰符。" class="headerlink" title="使用lastIndex属性，可以更好地说明y修饰符。"></a>使用lastIndex属性，可以更好地说明y修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">'xaya'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在3号位置匹配成功</span></span><br><span class="line">match.index <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4号位开始匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">'xaya'</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。"><a href="#上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。" class="headerlink" title="上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。"></a>上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。</h3><h3 id="y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。"><a href="#y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。" class="headerlink" title="y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。"></a>y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/y</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">'xaya'</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">'xaya'</span>);</span><br><span class="line">match.index <span class="comment">// 3</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h3 id="实际上，y修饰符号隐含了头部匹配的标志-。"><a href="#实际上，y修饰符号隐含了头部匹配的标志-。" class="headerlink" title="实际上，y修饰符号隐含了头部匹配的标志^。"></a>实际上，y修饰符号隐含了头部匹配的标志^。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/b/y.exec(<span class="string">'aba'</span>)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志-在全局匹配中都有效。"><a href="#上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志-在全局匹配中都有效。" class="headerlink" title="上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。"></a>上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</h3><p>???????????↑</p>
<h3 id="下面是字符串对象的replace方法的例子。"><a href="#下面是字符串对象的replace方法的例子。" class="headerlink" title="下面是字符串对象的replace方法的例子。"></a>下面是字符串对象的replace方法的例子。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/gy</span>;</span><br><span class="line"><span class="string">'aaxa'</span>.replace(REGEX, <span class="string">'-'</span>) <span class="comment">// '--xa'</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。"><a href="#上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。" class="headerlink" title="上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。"></a>上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。</h3><h3 id="单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。"><a href="#单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。" class="headerlink" title="单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。"></a>单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/y</span>) <span class="comment">// ["a1"]</span></span><br><span class="line"><span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/gy</span>) <span class="comment">// ["a1", "a2", "a3"]</span></span><br></pre></td></tr></table></figure>
<h3 id="y修饰符的一个应用，是从字符串提取-token（词元），y修饰符确保了匹配之间不会有漏掉的字符。"><a href="#y修饰符的一个应用，是从字符串提取-token（词元），y修饰符确保了匹配之间不会有漏掉的字符。" class="headerlink" title="y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。"></a>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TOKEN_Y = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line"><span class="keyword">const</span> TOKEN_G  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">'3 + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3 + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> (match = TOKEN_REGEX.exec(str)) &#123;</span><br><span class="line">    result.push(match[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。"><a href="#上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。" class="headerlink" title="上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。"></a>上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tokenize(TOKEN_Y, <span class="string">'3x + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3' ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3x + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。"><a href="#上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。" class="headerlink" title="上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。"></a>上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。</h3><h1 id="6-RegExp-prototype-sticky-属性"><a href="#6-RegExp-prototype-sticky-属性" class="headerlink" title="6.RegExp.prototype.sticky 属性"></a>6.RegExp.prototype.sticky 属性</h1><h3 id="与y修饰符相匹配，ES6-的正则实例对象多了sticky属性，表示是否设置了y修饰符。"><a href="#与y修饰符相匹配，ES6-的正则实例对象多了sticky属性，表示是否设置了y修饰符。" class="headerlink" title="与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。"></a>与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<hr>
<ol start="7">
<li>RegExp.prototype.flags 属性<h3 id="ES6-为正则表达式新增了flags属性，会返回正则表达式的修饰符。"><a href="#ES6-为正则表达式新增了flags属性，会返回正则表达式的修饰符。" class="headerlink" title="ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。"></a>ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的 source 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">/abc/ig.source</span><br><span class="line"><span class="comment">// "abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的 flags 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">/abc/ig.flags</span><br><span class="line"><span class="comment">// 'gi'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="8-s-修饰符：dotAll-模式"><a href="#8-s-修饰符：dotAll-模式" class="headerlink" title="8.s 修饰符：dotAll 模式"></a>8.s 修饰符：dotAll 模式</h1><h3 id="正则表达式中，点（-）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的-UTF-16-字符，这个可以用u修饰符解决；另一个是行终止符（line-terminator-character）。"><a href="#正则表达式中，点（-）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的-UTF-16-字符，这个可以用u修饰符解决；另一个是行终止符（line-terminator-character）。" class="headerlink" title="正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。"></a>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。</h3><h3 id="所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。"><a href="#所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。" class="headerlink" title="所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。"></a>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</h3><blockquote>
<p>U+000A 换行符（\n）<br>U+000D 回车符（\r）<br>U+2028 行分隔符（line separator）<br>U+2029 段分隔符（paragraph separator）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/.test(<span class="string">'foo\nbar'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="上面代码中，因为-不匹配-n，所以正则表达式返回false。"><a href="#上面代码中，因为-不匹配-n，所以正则表达式返回false。" class="headerlink" title="上面代码中，因为.不匹配\n，所以正则表达式返回false。"></a>上面代码中，因为.不匹配\n，所以正则表达式返回false。</h3><h3 id="但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。"><a href="#但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。" class="headerlink" title="但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。"></a>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo[^]bar/.test(<span class="string">'foo\nbar'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="这种解决方案毕竟不太符合直觉，ES2018-引入s修饰符，使得-可以匹配任意单个字符。"><a href="#这种解决方案毕竟不太符合直觉，ES2018-引入s修饰符，使得-可以匹配任意单个字符。" class="headerlink" title="这种解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。"></a>这种解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">'foo\nbar'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。"><a href="#这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。" class="headerlink" title="这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。"></a>这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="comment">// const re = new RegExp('foo.bar', 's');</span></span><br><span class="line"></span><br><span class="line">re.test(<span class="string">'foo\nbar'</span>) <span class="comment">// true</span></span><br><span class="line">re.dotAll <span class="comment">// true</span></span><br><span class="line">re.flags <span class="comment">// 's'</span></span><br></pre></td></tr></table></figure>
<h3 id="s修饰符和多行修饰符-m不冲突，两者一起使用的情况下，-匹配所有字符，而-和-匹配每一行的行首和行尾。"><a href="#s修饰符和多行修饰符-m不冲突，两者一起使用的情况下，-匹配所有字符，而-和-匹配每一行的行首和行尾。" class="headerlink" title="/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。"></a>/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。</h3><hr>
<h1 id="9-后行断言"><a href="#9-后行断言" class="headerlink" title="9.后行断言"></a>9.后行断言</h1><h3 id="JavaScript-语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative-lookahead），不支持后行断言（lookbehind）和后行否定断言（negative-lookbehind）。ES2018-引入后行断言，V8-引擎-4-9-版（Chrome-62）已经支持。"><a href="#JavaScript-语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative-lookahead），不支持后行断言（lookbehind）和后行否定断言（negative-lookbehind）。ES2018-引入后行断言，V8-引擎-4-9-版（Chrome-62）已经支持。" class="headerlink" title="JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。"></a>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。</h3><h3 id="“先行断言”指的是，x只有在y前面才匹配，必须写成-x-y-。比如，只匹配百分号之前的数字，要写成-d-。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成-x-y-。比如，只匹配不在百分号之前的数字，要写成-d-。"><a href="#“先行断言”指的是，x只有在y前面才匹配，必须写成-x-y-。比如，只匹配百分号之前的数字，要写成-d-。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成-x-y-。比如，只匹配不在百分号之前的数字，要写成-d-。" class="headerlink" title="“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。"></a>“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?=%)/.exec(<span class="string">'100% of US presidents have been male'</span>)  <span class="comment">// ["100"]</span></span><br><span class="line">/\d+(?!%)/.exec(<span class="string">'that’s all 44 of them'</span>)                 <span class="comment">// ["44"]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（-），是不计入返回结果的。"><a href="#上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（-），是不计入返回结果的。" class="headerlink" title="上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。"></a>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。</h3><h3 id="“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成-lt-y-x-。比如，只匹配美元符号之后的数字，要写成-lt-d-。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成-lt-y-x-。比如，只匹配不在美元符号后面的数字，要写成-lt-d-。"><a href="#“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成-lt-y-x-。比如，只匹配美元符号之后的数字，要写成-lt-d-。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成-lt-y-x-。比如，只匹配不在美元符号后面的数字，要写成-lt-d-。" class="headerlink" title="“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。"></a>“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=\$)\d+/.exec('Benjamin Franklin is on the $100 bill')  // ["100"]</span><br><span class="line">/(?&lt;!\$)\d+/.exec('it’s is worth about €90')                // ["90"]</span><br></pre></td></tr></table></figure>
<h3 id="上面的例子中，“后行断言”的括号之中的部分（-lt-），也是不计入返回结果。"><a href="#上面的例子中，“后行断言”的括号之中的部分（-lt-），也是不计入返回结果。" class="headerlink" title="上面的例子中，“后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。"></a>上面的例子中，“后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。</h3><h3 id="下面的例子是使用后行断言进行字符串替换。"><a href="#下面的例子是使用后行断言进行字符串替换。" class="headerlink" title="下面的例子是使用后行断言进行字符串替换。"></a>下面的例子是使用后行断言进行字符串替换。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DOLLAR_PREFIX = <span class="regexp">/(?&lt;=\$)foo/g</span>;</span><br><span class="line"><span class="string">'$foo %foo foo'</span>.replace(RE_DOLLAR_PREFIX, <span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// '$bar %foo foo'</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，只有在美元符号后面的foo才会被替换。"><a href="#上面代码中，只有在美元符号后面的foo才会被替换。" class="headerlink" title="上面代码中，只有在美元符号后面的foo才会被替换。"></a>上面代码中，只有在美元符号后面的foo才会被替换。</h3><h3 id="“后行断言”的实现，需要先匹配-lt-y-x-的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。"><a href="#“后行断言”的实现，需要先匹配-lt-y-x-的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。" class="headerlink" title="“后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。"></a>“后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</h3><h3 id="首先，后行断言的组匹配，与正常情况下结果是不一样的。"><a href="#首先，后行断言的组匹配，与正常情况下结果是不一样的。" class="headerlink" title="首先，后行断言的组匹配，与正常情况下结果是不一样的。"></a>首先，后行断言的组匹配，与正常情况下结果是不一样的。</h3><blockquote>
<p>下面的这个！！！不懂呀！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=(\d+)(\d+))$/.exec('1053') // ["", "1", "053"]</span><br><span class="line">/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。"><a href="#上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。" class="headerlink" title="上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。"></a>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。</h3><h3 id="其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。"><a href="#其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。" class="headerlink" title="其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。"></a>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=(o)d\1)r/.exec('hodor')  // null</span><br><span class="line">/(?&lt;=\1d(o))r/.exec('hodor')  // ["r", "o"]</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，如果后行断言的反斜杠引用（-1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。"><a href="#上面代码中，如果后行断言的反斜杠引用（-1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。" class="headerlink" title="上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。"></a>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</h3><h3 id="其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。-1"><a href="#其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。-1" class="headerlink" title="其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。"></a>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=(o)d\1)r/.exec('hodor')  // null</span><br><span class="line">/(?&lt;=\1d(o))r/.exec('hodor')  // ["r", "o"]</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，如果后行断言的反斜杠引用（-1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。-1"><a href="#上面代码中，如果后行断言的反斜杠引用（-1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。-1" class="headerlink" title="上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。"></a>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</h3><hr>
<h1 id="10-Unicode-属性类"><a href="#10-Unicode-属性类" class="headerlink" title="10.Unicode 属性类"></a>10.Unicode 属性类</h1><h3 id="ES2018-引入了一种新的类的写法-p-…-和-P-…-，允许正则表达式匹配符合-Unicode-某种属性的所有字符。"><a href="#ES2018-引入了一种新的类的写法-p-…-和-P-…-，允许正则表达式匹配符合-Unicode-某种属性的所有字符。" class="headerlink" title="ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。"></a>ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">regexGreekSymbol.test(<span class="string">'π'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，-p-Script-Greek-指定匹配一个希腊文字母，所以匹配π成功。"><a href="#上面代码中，-p-Script-Greek-指定匹配一个希腊文字母，所以匹配π成功。" class="headerlink" title="上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。"></a>上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。</h3><h3 id="Unicode-属性类要指定属性名和属性值。"><a href="#Unicode-属性类要指定属性名和属性值。" class="headerlink" title="Unicode 属性类要指定属性名和属性值。"></a>Unicode 属性类要指定属性名和属性值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName=UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对于某些属性，可以只写属性名，或者只写属性值。"><a href="#对于某些属性，可以只写属性名，或者只写属性值。" class="headerlink" title="对于某些属性，可以只写属性名，或者只写属性值。"></a>对于某些属性，可以只写属性名，或者只写属性值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName&#125;</span><br><span class="line">\p&#123;UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P-…-是-p-…-的反向匹配，即匹配不满足条件的字符。"><a href="#P-…-是-p-…-的反向匹配，即匹配不满足条件的字符。" class="headerlink" title="\P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。"></a>\P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。</h3><h3 id="注意，这两种类只对-Unicode-有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用-p和-P会报错，ECMAScript-预留了这两个类。"><a href="#注意，这两种类只对-Unicode-有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用-p和-P会报错，ECMAScript-预留了这两个类。" class="headerlink" title="注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。"></a>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。</h3><h3 id="由于-Unicode-的各种属性非常多，所以这种新的类的表达能力非常强。"><a href="#由于-Unicode-的各种属性非常多，所以这种新的类的表达能力非常强。" class="headerlink" title="由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。"></a>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Decimal_Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">'𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。"><a href="#上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。" class="headerlink" title="上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。"></a>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</h3><h3 id="p-Number-甚至能匹配罗马数字。"><a href="#p-Number-甚至能匹配罗马数字。" class="headerlink" title="\p{Number}甚至能匹配罗马数字。"></a>\p{Number}甚至能匹配罗马数字。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有数字</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">'²³¹¼½¾'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'㉛㉜㉝'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="下面是其他一些例子。"><a href="#下面是其他一些例子。" class="headerlink" title="下面是其他一些例子。"></a>下面是其他一些例子。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有空格</span></span><br><span class="line">\p&#123;White_Space&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 Emoji</span></span><br><span class="line">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line"><span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">regexArrows.test(<span class="string">'←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="11-具名组匹配"><a href="#11-具名组匹配" class="headerlink" title="11.具名组匹配"></a>11.具名组匹配</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="正则表达式使用圆括号进行组匹配。"><a href="#正则表达式使用圆括号进行组匹配。" class="headerlink" title="正则表达式使用圆括号进行组匹配。"></a>正则表达式使用圆括号进行组匹配。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。"><a href="#上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。" class="headerlink" title="上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。"></a>上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<h3 id="组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj-1-）引用，要是组的顺序变了，引用的时候就必须修改序号。"><a href="#组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj-1-）引用，要是组的顺序变了，引用的时候就必须修改序号。" class="headerlink" title="组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。"></a>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。</h3><h3 id="ES2018-引入了具名组匹配（Named-Capture-Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。"><a href="#ES2018-引入了具名组匹配（Named-Capture-Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。" class="headerlink" title="ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。"></a>ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号-尖括号-组名”（-），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj-1-）依然有效。"><a href="#上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号-尖括号-组名”（-），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj-1-）依然有效。" class="headerlink" title="上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。"></a>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?<year>），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。</year></h3><h3 id="具名组匹配等于为每一组匹配加上了-ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。"><a href="#具名组匹配等于为每一组匹配加上了-ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。" class="headerlink" title="具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。"></a>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</h3><h3 id="如果具名组没有匹配，那么对应的groups对象属性会是undefined。"><a href="#如果具名组没有匹配，那么对应的groups对象属性会是undefined。" class="headerlink" title="如果具名组没有匹配，那么对应的groups对象属性会是undefined。"></a>如果具名组没有匹配，那么对应的groups对象属性会是undefined。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_OPT_A = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_OPT_A.exec(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">matchObj.groups.as <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'as'</span> <span class="keyword">in</span> matchObj.groups <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，具名组as没有找到匹配，那么matchObj-groups-as属性值就是undefined，并且as这个键名在groups是始终存在的。"><a href="#上面代码中，具名组as没有找到匹配，那么matchObj-groups-as属性值就是undefined，并且as这个键名在groups是始终存在的。" class="headerlink" title="上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。"></a>上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。</h3><hr>
<h1 id="解构赋值和替换"><a href="#解构赋值和替换" class="headerlink" title="解构赋值和替换"></a>解构赋值和替换</h1><h3 id="有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。"><a href="#有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。" class="headerlink" title="有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。"></a>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class="string">'foo:bar'</span>);</span><br><span class="line">one  <span class="comment">// foo</span></span><br><span class="line">two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串替换时，使用-lt-组名-gt-引用具名组。"><a href="#字符串替换时，使用-lt-组名-gt-引用具名组。" class="headerlink" title="字符串替换时，使用$&lt;组名&gt;引用具名组。"></a>字符串替换时，使用$&lt;组名&gt;引用具名组。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">'2015-01-02'</span>.replace(re, <span class="string">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br><span class="line"><span class="comment">// '02/01/2015'</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。"><a href="#上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。" class="headerlink" title="上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。"></a>上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。</h3><h3 id="replace方法的第二个参数也可以是函数，该函数的参数序列如下。"><a href="#replace方法的第二个参数也可以是函数，该函数的参数序列如下。" class="headerlink" title="replace方法的第二个参数也可以是函数，该函数的参数序列如下。"></a>replace方法的第二个参数也可以是函数，该函数的参数序列如下。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'2015-01-02'</span>.replace(re, (</span><br><span class="line">   matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span><br><span class="line">   capture1, <span class="comment">// 第一个组匹配 2015</span></span><br><span class="line">   capture2, <span class="comment">// 第二个组匹配 01</span></span><br><span class="line">   capture3, <span class="comment">// 第三个组匹配 02</span></span><br><span class="line">   position, <span class="comment">// 匹配开始的位置 0</span></span><br><span class="line">   S, <span class="comment">// 原字符串 2015-01-02</span></span><br><span class="line">   groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span><br><span class="line"> ) =&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> &#123;day, month, year&#125; = groups;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;day&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。"><a href="#具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。" class="headerlink" title="具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。"></a>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</h3><hr>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h3 id="如果要在正则表达式内部引用某个“具名组匹配”，可以使用-k-lt-组名-gt-的写法。"><a href="#如果要在正则表达式内部引用某个“具名组匹配”，可以使用-k-lt-组名-gt-的写法。" class="headerlink" title="如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。"></a>如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="数字引用（-1）依然有效。"><a href="#数字引用（-1）依然有效。" class="headerlink" title="数字引用（\1）依然有效。"></a>数字引用（\1）依然有效。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="这两种引用语法还可以同时使用。"><a href="#这两种引用语法还可以同时使用。" class="headerlink" title="这两种引用语法还可以同时使用。"></a>这两种引用语法还可以同时使用。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="12-String-prototype-matchAll"><a href="#12-String-prototype-matchAll" class="headerlink" title="12.String.prototype.matchAll()"></a>12.String.prototype.matchAll()</h1><h3 id="如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。"><a href="#如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。" class="headerlink" title="如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。"></a>如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'test1test2test3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = [];</span><br><span class="line"><span class="keyword">var</span> match;</span><br><span class="line"><span class="keyword">while</span> (match = regex.exec(string)) &#123;</span><br><span class="line">  matches.push(match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matches</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"],</span></span><br><span class="line"><span class="comment">//   ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"],</span></span><br><span class="line"><span class="comment">//   ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，while循环取出每一轮的正则匹配，一共三轮。"><a href="#上面代码中，while循环取出每一轮的正则匹配，一共三轮。" class="headerlink" title="上面代码中，while循环取出每一轮的正则匹配，一共三轮。"></a>上面代码中，while循环取出每一轮的正则匹配，一共三轮。</h3><h3 id="ES2020-增加了String-prototype-matchAll-方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。"><a href="#ES2020-增加了String-prototype-matchAll-方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。" class="headerlink" title="ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。"></a>ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">'test1test2test3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g 修饰符加不加都可以</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.matchAll(regex)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，由于string-matchAll-regex-返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。"><a href="#上面代码中，由于string-matchAll-regex-返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。" class="headerlink" title="上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。"></a>上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</h3><h3 id="遍历器转为数组是非常简单的，使用…运算符和Array-from-方法就可以了。"><a href="#遍历器转为数组是非常简单的，使用…运算符和Array-from-方法就可以了。" class="headerlink" title="遍历器转为数组是非常简单的，使用…运算符和Array.from()方法就可以了。"></a>遍历器转为数组是非常简单的，使用…运算符和Array.from()方法就可以了。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转为数组方法一</span></span><br><span class="line">[...string.matchAll(regex)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为数组方法二</span></span><br><span class="line"><span class="built_in">Array</span>.from(string.matchAll(regex))</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Q-Quiet.github.io/2020/02/07/es6-5-正则的扩展/" data-id="cklg8rx9t002f2cuprltivxc2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es6-4-字符串的新增方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/05/es6-4-字符串的新增方法/" class="article-date">
  <time datetime="2020-02-05T07:24:22.000Z" itemprop="datePublished">2020-02-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/05/es6-4-字符串的新增方法/">es6-4-字符串的新增方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-String-fromCodePoint"><a href="#1-String-fromCodePoint" class="headerlink" title="1.String.fromCodePoint()"></a>1.String.fromCodePoint()</h1><h4 id="ES5提供的String-fromCharCode-的方法，用于Unicode码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符"><a href="#ES5提供的String-fromCharCode-的方法，用于Unicode码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符" class="headerlink" title="ES5提供的String.fromCharCode()的方法，用于Unicode码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符"></a>ES5提供的<code>String.fromCharCode()</code>的方法，用于Unicode码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">//"ஷ"</span></span><br></pre></td></tr></table></figure>
<h4 id="因为不能识别码点大于0xFFFF的字符，所以0x20BB7发生了溢出，最高位2被舍弃，最后返回码点U-0BB7对应的字符。"><a href="#因为不能识别码点大于0xFFFF的字符，所以0x20BB7发生了溢出，最高位2被舍弃，最后返回码点U-0BB7对应的字符。" class="headerlink" title="因为不能识别码点大于0xFFFF的字符，所以0x20BB7发生了溢出，最高位2被舍弃，最后返回码点U+0BB7对应的字符。"></a>因为不能识别码点大于<code>0xFFFF</code>的字符，所以<code>0x20BB7</code>发生了溢出，最高位2被舍弃，最后返回码点<code>U+0BB7</code>对应的字符。</h4><h4 id="ES6-的String-fromCodePoint-方法，可以识别大于0xFFFF的字符。"><a href="#ES6-的String-fromCodePoint-方法，可以识别大于0xFFFF的字符。" class="headerlink" title="ES6 的String.fromCodePoint()方法，可以识别大于0xFFFF的字符。"></a>ES6 的String.fromCodePoint()方法，可以识别大于0xFFFF的字符。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">'x\uD83D\uDE80y'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="在作用上，正好与codePointAt-方法相反。"><a href="#在作用上，正好与codePointAt-方法相反。" class="headerlink" title="在作用上，正好与codePointAt()方法相反。"></a>在作用上，正好与codePointAt()方法相反。</h4><h4 id="注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。"><a href="#注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。" class="headerlink" title="注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。"></a>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</h4><hr>
<h1 id="2-String-raw"><a href="#2-String-raw" class="headerlink" title="2.String.raw()"></a>2.String.raw()</h1><h4 id="该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。"><a href="#该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。" class="headerlink" title="该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。"></a>该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span></span><br><span class="line"><span class="comment">// 实际返回 "Hi\\n5!"，显示的是转义后的结果 "Hi\n5!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 实际返回 "Hi\\u000A!"，显示的是转义后的结果 "Hi\u000A!"</span></span><br></pre></td></tr></table></figure>
<h4 id="如果原字符串的斜杠已经转义，那么String-raw-会进行再次转义。"><a href="#如果原字符串的斜杠已经转义，那么String-raw-会进行再次转义。" class="headerlink" title="如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。"></a>如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span></span><br><span class="line"><span class="comment">// 返回 "Hi\\\\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span> === <span class="string">"Hi\\\\n"</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="String-raw-本质上是一个正常的函数，只是专用于模板字符串的-标签函数-。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。"><a href="#String-raw-本质上是一个正常的函数，只是专用于模板字符串的-标签函数-。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。" class="headerlink" title="String.raw()本质上是一个正常的函数，只是专用于模板字符串的==标签函数==。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。"></a>String.raw()本质上是一个正常的函数，只是专用于模板字符串的==标签函数==。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `foo$&#123;1 + 2&#125;bar`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>] &#125;, <span class="number">1</span> + <span class="number">2</span>) <span class="comment">// "foo3bar"</span></span><br></pre></td></tr></table></figure>
<h4 id="上面代码中，String-raw-方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。"><a href="#上面代码中，String-raw-方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。" class="headerlink" title="上面代码中，String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。"></a>上面代码中，String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。</h4><h4 id="作为函数，String-raw-的代码实现基本如下。"><a href="#作为函数，String-raw-的代码实现基本如下。" class="headerlink" title="作为函数，String.raw()的代码实现基本如下。"></a>作为函数，String.raw()的代码实现基本如下。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span> (<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += strings.raw[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += strings.raw[index]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-实例方法：codePointAt"><a href="#3-实例方法：codePointAt" class="headerlink" title="3.实例方法：codePointAt()"></a>3.实例方法：codePointAt()</h1><h4 id="在JavaScript内部，字符以UTF-16-的格式存储，每个字符固定为2个字符。对于那些需要四个字节储存的字符-Unicode码点大于0xFFFF的字符-，JavaScript会认为他们是两个字符。"><a href="#在JavaScript内部，字符以UTF-16-的格式存储，每个字符固定为2个字符。对于那些需要四个字节储存的字符-Unicode码点大于0xFFFF的字符-，JavaScript会认为他们是两个字符。" class="headerlink" title="在JavaScript内部，字符以UTF-16 的格式存储，每个字符固定为2个字符。对于那些需要四个字节储存的字符(Unicode码点大于0xFFFF的字符)，JavaScript会认为他们是两个字符。"></a>在JavaScript内部，字符以UTF-16 的格式存储，每个字符固定为2个字符。对于那些需要四个字节储存的字符(Unicode码点大于0xFFFF的字符)，JavaScript会认为他们是两个字符。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 2</span></span><br><span class="line">s.charAt(<span class="number">0</span>) <span class="comment">// ''</span></span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// ''</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure>
<h4 id="上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16-编码为0xD842-0xDFB7（十进制为55362-57271），需要4个字节储存。对于这种4个字节的字符，JavaScript-不能正确处理，字符串长度会误判为2，而且charAt-方法无法读取整个字符，charCodeAt-方法只能分别返回前两个字节和后两个字节的值。"><a href="#上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16-编码为0xD842-0xDFB7（十进制为55362-57271），需要4个字节储存。对于这种4个字节的字符，JavaScript-不能正确处理，字符串长度会误判为2，而且charAt-方法无法读取整个字符，charCodeAt-方法只能分别返回前两个字节和后两个字节的值。" class="headerlink" title="上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。"></a>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。</h4><h4 id="ES6提供了codePointAt-方法，能够正确处理4个字节存储的字符，返回一个字符的码点。"><a href="#ES6提供了codePointAt-方法，能够正确处理4个字节存储的字符，返回一个字符的码点。" class="headerlink" title="ES6提供了codePointAt()方法，能够正确处理4个字节存储的字符，返回一个字符的码点。"></a>ES6提供了codePointAt()方法，能够正确处理4个字节存储的字符，返回一个字符的码点。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>
<h4 id="codePointAt-方法的参数，是字符在字符串中的位置（从-0-开始）。上面代码中，JavaScript-将“𠮷a”视为三个字符，codePointAt-方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点-134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt-方法的结果与charCodeAt-方法相同。"><a href="#codePointAt-方法的参数，是字符在字符串中的位置（从-0-开始）。上面代码中，JavaScript-将“𠮷a”视为三个字符，codePointAt-方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点-134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt-方法的结果与charCodeAt-方法相同。" class="headerlink" title="codePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。"></a>codePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。</h4><h4 id="因为，codePointAt-返回的是码点的十进制值，如果想要十六进制的值，可以使用，toString-方法转换一下。"><a href="#因为，codePointAt-返回的是码点的十进制值，如果想要十六进制的值，可以使用，toString-方法转换一下。" class="headerlink" title="因为，codePointAt()返回的是码点的十进制值，如果想要十六进制的值，可以使用，toString()方法转换一下。"></a>因为，codePointAt()返回的是码点的十进制值，如果想要十六进制的值，可以使用，toString()方法转换一下。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// "20bb7"</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>) <span class="comment">// "61"</span></span><br></pre></td></tr></table></figure>
<h4 id="你可能注意到了，codePointAt-方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是-1，但是必须向codePointAt-方法传入-2。解决这个问题的一个办法是使用-for…of-循环，因为它会正确识别-32-位的-UTF-16-字符。"><a href="#你可能注意到了，codePointAt-方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是-1，但是必须向codePointAt-方法传入-2。解决这个问题的一个办法是使用-for…of-循环，因为它会正确识别-32-位的-UTF-16-字符。" class="headerlink" title="你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用==for…of==循环，因为它会正确识别 32 位的 UTF-16 字符。"></a>你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用==for…of==循环，因为它会正确识别 32 位的 UTF-16 字符。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>
<h4 id="另一种方法也可以，使用扩展运算符（…）进行展开运算。"><a href="#另一种方法也可以，使用扩展运算符（…）进行展开运算。" class="headerlink" title="另一种方法也可以，使用扩展运算符（…）进行展开运算。"></a>另一种方法也可以，使用扩展运算符（…）进行展开运算。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...<span class="string">'𠮷a'</span>]; <span class="comment">// arr.length === 2</span></span><br><span class="line">arr.forEach(</span><br><span class="line">  ch =&gt; <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>
<h4 id="codePointAt-方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。"><a href="#codePointAt-方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。" class="headerlink" title="codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。"></a>codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">"𠮷"</span>) <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">"a"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="4-实例方法：normalize"><a href="#4-实例方法：normalize" class="headerlink" title="4.实例方法：normalize()"></a>4.实例方法：normalize()</h1><blockquote>
<p>？？？？重音可还行</p>
</blockquote>
<h4 id="许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode-提供了两种方法。一种是直接提供带重音符号的字符，比如O（-u01D1）。另一种是提供合成符号（combining-character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（-u004F）和ˇ（-u030C）合成O（-u004F-u030C）。"><a href="#许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode-提供了两种方法。一种是直接提供带重音符号的字符，比如O（-u01D1）。另一种是提供合成符号（combining-character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（-u004F）和ˇ（-u030C）合成O（-u004F-u030C）。" class="headerlink" title="许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。"></a>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</h4><h4 id="这两种表示方法，在视觉和语义上都等价，-但是-JavaScript-不能识别。"><a href="#这两种表示方法，在视觉和语义上都等价，-但是-JavaScript-不能识别。" class="headerlink" title="这两种表示方法，在视觉和语义上都等价，==但是 JavaScript 不能识别。=="></a>这两种表示方法，在视觉和语义上都等价，==但是 JavaScript 不能识别。==</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u01D1'</span>.length <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="上面代码表示，JavaScript-将合成字符视为两个字符，导致两种表示方法不相等。"><a href="#上面代码表示，JavaScript-将合成字符视为两个字符，导致两种表示方法不相等。" class="headerlink" title="上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。"></a>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</h4><h4 id="ES6-提供字符串实例的normalize-方法，用来将字符的不同表示方法统一为同样的形式，这称为-Unicode-正规化。"><a href="#ES6-提供字符串实例的normalize-方法，用来将字符的不同表示方法统一为同样的形式，这称为-Unicode-正规化。" class="headerlink" title="ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。"></a>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。"><a href="#normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。" class="headerlink" title="normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。"></a>normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。</h4><ul>
<li>NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>
<li>NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>
<li>NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）</li>
<li>NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过-Unicode-编号区间判断。"><a href="#不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过-Unicode-编号区间判断。" class="headerlink" title="==不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。=="></a>==不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。==</h4><hr>
<h1 id="6-实例方法：repeat"><a href="#6-实例方法：repeat" class="headerlink" title="6.实例方法：repeat()"></a>6.实例方法：repeat()</h1><ul>
<li><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>参数如果是小数，会被取整。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果repeat的参数是负数或者Infinity，会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>参数NaN等同于 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果repeat的参数是字符串，则会先转换成数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="7-实例方法：padStart-，padEnd"><a href="#7-实例方法：padStart-，padEnd" class="headerlink" title="7.实例方法：padStart()，padEnd()"></a>7.实例方法：padStart()，padEnd()</h1><h4 id="ES2017-引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart-用于头部补全，padEnd-用于尾部补全。"><a href="#ES2017-引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart-用于头部补全，padEnd-用于尾部补全。" class="headerlink" title="ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。"></a>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure>
<h4 id="上面代码中，padStart-和padEnd-一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。"><a href="#上面代码中，padStart-和padEnd-一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。" class="headerlink" title="上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。"></a>上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</h4><h4 id="如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。"><a href="#如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。" class="headerlink" title="如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。"></a>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></span><br></pre></td></tr></table></figure>
<h4 id="如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。"><a href="#如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。" class="headerlink" title="如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。"></a>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)</span><br><span class="line"><span class="comment">// '0123456abc'</span></span><br></pre></td></tr></table></figure>
<h4 id="如果省略第二个参数，默认使用空格补全长度。"><a href="#如果省略第二个参数，默认使用空格补全长度。" class="headerlink" title="如果省略第二个参数，默认使用空格补全长度。"></a>如果省略第二个参数，默认使用空格补全长度。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="comment">// '   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="comment">// 'x   '</span></span><br></pre></td></tr></table></figure>
<h4 id="padStart-的常见用途是为数值补全指定位数。下面代码生成-10-位的数值字符串。"><a href="#padStart-的常见用途是为数值补全指定位数。下面代码生成-10-位的数值字符串。" class="headerlink" title="padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。"></a>padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000001"</span></span><br><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000012"</span></span><br><span class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></span><br></pre></td></tr></table></figure>
<h4 id="另一个用途是提示字符串格式。"><a href="#另一个用途是提示字符串格式。" class="headerlink" title="另一个用途是提示字符串格式。"></a>另一个用途是提示字符串格式。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></span><br><span class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-09-12"</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="8-实例方法：trimStart-，trimEnd-§-⇧"><a href="#8-实例方法：trimStart-，trimEnd-§-⇧" class="headerlink" title="8.实例方法：trimStart()，trimEnd() § ⇧"></a>8.实例方法：trimStart()，trimEnd() § ⇧</h1><h4 id="ES2019-对字符串实例新增了trimStart-和trimEnd-这两个方法。它们的行为与trim-一致，trimStart-消除字符串头部的空格，trimEnd-消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。"><a href="#ES2019-对字符串实例新增了trimStart-和trimEnd-这两个方法。它们的行为与trim-一致，trimStart-消除字符串头部的空格，trimEnd-消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。" class="headerlink" title="ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。"></a>ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</h4><blockquote>
<p>trim() 方法返回一个从两头去掉空白字符的字符串，并不影响原字符串本身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">'  abc  '</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="comment">// "abc"</span></span><br><span class="line">s.trimStart() <span class="comment">// "abc  "</span></span><br><span class="line">s.trimEnd() <span class="comment">// "  abc"</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="上面代码中，trimStart-只消除头部的空格，保留尾部的空格。trimEnd-也是类似行为。"><a href="#上面代码中，trimStart-只消除头部的空格，保留尾部的空格。trimEnd-也是类似行为。" class="headerlink" title="上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。"></a>上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。</h4><h4 id="除了空格键，这两个方法对字符串头部（或尾部）的-tab-键、换行符等不可见的空白符号也有效。"><a href="#除了空格键，这两个方法对字符串头部（或尾部）的-tab-键、换行符等不可见的空白符号也有效。" class="headerlink" title="除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。"></a>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</h4><h4 id="浏览器还部署了额外的两个方法，trimLeft-是trimStart-的别名，trimRight-是trimEnd-的别名。"><a href="#浏览器还部署了额外的两个方法，trimLeft-是trimStart-的别名，trimRight-是trimEnd-的别名。" class="headerlink" title="浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。"></a>浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。</h4><hr>
<h1 id="9-实例方法：matchAll"><a href="#9-实例方法：matchAll" class="headerlink" title="9.实例方法：matchAll()"></a>9.实例方法：matchAll()</h1><h4 id="matchAll-方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。"><a href="#matchAll-方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。" class="headerlink" title="matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。"></a>matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://Q-Quiet.github.io/2020/02/05/es6-4-字符串的新增方法/" data-id="cklg8rx9g00282cupqq2td4s7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es6-3-字符串的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/05/es6-3-字符串的扩展/" class="article-date">
  <time datetime="2020-02-05T07:18:18.000Z" itemprop="datePublished">2020-02-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/05/es6-3-字符串的扩展/">es6-3-字符串的扩展</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-字符的Unicode表示法"><a href="#1-字符的Unicode表示法" class="headerlink" title="1. 字符的Unicode表示法"></a>1. 字符的Unicode表示法</h1><h2 id="只限于-u0000-uFFFF-之间的字符，超过范围的，需要用两个双字节的形式表示。"><a href="#只限于-u0000-uFFFF-之间的字符，超过范围的，需要用两个双字节的形式表示。" class="headerlink" title="只限于\u0000~\uFFFF`之间的字符，超过范围的，需要用两个双字节的形式表示。"></a>只限于<code>\u0000</code>~<code>\uFFFF`</code>之间的字符，超过范围的，需要用两个双字节的形式表示。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="string">"\uD842\uDF87"</span></span><br><span class="line"><span class="comment">// "吉"</span></span><br></pre></td></tr></table></figure>
<h2 id="如果在-u后面跟上超过0xFFFF的数值，只要将码点放入大括号，就能正确解读该字符。"><a href="#如果在-u后面跟上超过0xFFFF的数值，只要将码点放入大括号，就能正确解读该字符。" class="headerlink" title="如果在\u后面跟上超过0xFFFF的数值，只要将码点放入大括号，就能正确解读该字符。"></a>如果在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值，只要将码点放入大括号，就能正确解读该字符。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<h1 id="2-字符串的遍历器接口"><a href="#2-字符串的遍历器接口" class="headerlink" title="2.字符串的遍历器接口"></a>2.字符串的遍历器接口</h1><blockquote>
<p>详情见《Iterator》一章，使得字符串可以被<code>for...of</code>循环遍历、<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "f"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure></p>
<h1 id="3-直接输入U-2028-和-U-2029"><a href="#3-直接输入U-2028-和-U-2029" class="headerlink" title="3.直接输入U+2028 和 U+2029"></a>3.直接输入U+2028 和 U+2029</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'中'</span> === <span class="string">'\u4e2d'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。</p>
<p>U+005C：反斜杠（reverse solidus)<br>U+000D：回车（carriage return）<br>U+2028：行分隔符（line separator）<br>U+2029：段分隔符（paragraph separator）<br>U+000A：换行符（line feed）<br>举例来说，字符串里面不能直接包含反斜杠，一定要转义写成\或者\u005c。</p>
<h1 id="4-JSON-stringofy-的改造"><a href="#4-JSON-stringofy-的改造" class="headerlink" title="4.JSON.stringofy()的改造"></a>4.JSON.stringofy()的改造</h1><p>（还没学json）<br>JSON.stringify()的问题在于，它可能返回0xD800到0xDFFF之间的单个码点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// "\u&#123;D834&#125;"</span></span><br></pre></td></tr></table></figure></p>
<p>为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// ""\\uD834""</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\uDF06\uD834'</span>) <span class="comment">// ""\\udf06\\ud834""</span></span><br></pre></td></tr></table></figure></p>
<h1 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5.模板字符串"></a>5.模板字符串</h1><p>（用到了jQuery：咳咳，我还没学）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(</span><br><span class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">  <span class="string">'items in your basket, '</span> +</span><br><span class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="上面这种写法相当繁琐不方便，ES6-引入了模板字符串解决这个问题。"><a href="#上面这种写法相当繁琐不方便，ES6-引入了模板字符串解决这个问题。" class="headerlink" title="上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。"></a>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>.trim());</span><br></pre></td></tr></table></figure></ul></p>
<p>模板字符串中嵌入变量，需要将变量名写在${}之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="comment">// 传统写法为</span></span><br><span class="line">      <span class="comment">// 'User '</span></span><br><span class="line">      <span class="comment">// + user.name</span></span><br><span class="line">      <span class="comment">// + ' is not authorized to do '</span></span><br><span class="line">      <span class="comment">// + action</span></span><br><span class="line">      <span class="comment">// + '.'</span></span><br><span class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 4 = 5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "3"</span></span><br></pre></td></tr></table></figure></p>
<p>模板字符串之中还能调用函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure></p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量place没有声明</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">`Hello, <span class="subst">$&#123;place&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>
<p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`Hello <span class="subst">$&#123;<span class="string">'World'</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure></p>
<p>模板字符串甚至还能嵌套。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tmpl(data));</span><br><span class="line"><span class="comment">// &lt;table&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &lt;/table&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="6-实例：模板编译"><a href="#6-实例：模板编译" class="headerlink" title="6.实例：模板编译"></a>6.实例：模板编译</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置 JavaScript 代码，使用&lt;%= … %&gt;输出 JavaScript 表达式。<br>一种思路是将其转换为 JavaScript 表达式字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo(<span class="string">'&lt;ul&gt;'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; data.supplies.length; i++) &#123;</span><br><span class="line">  echo(<span class="string">'&lt;li&gt;'</span>);</span><br><span class="line">  echo(data.supplies[i]);</span><br><span class="line">  echo(<span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">echo(<span class="string">'&lt;/ul&gt;'</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个转换使用正则表达式就行了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line"><span class="keyword">let</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">template = template</span><br><span class="line">  .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">  .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line">template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后，将template封装在一个函数里面返回，就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script =</span><br><span class="line"><span class="string">`(function parse(data)&#123;</span></span><br><span class="line"><span class="string">  let output = "";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  function echo(html)&#123;</span></span><br><span class="line"><span class="string">    output += html;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123; template &#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return output;</span></span><br><span class="line"><span class="string">&#125;)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> script;</span><br></pre></td></tr></table></figure></p>
<p>将上面的内容拼装成一个模板编译函数compile。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line">  <span class="keyword">const</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">  template = template</span><br><span class="line">    .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">    .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line">  template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> script =</span><br><span class="line">  <span class="string">`(function parse(data)&#123;</span></span><br><span class="line"><span class="string">    let output = "";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function echo(html)&#123;</span></span><br><span class="line"><span class="string">      output += html;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    <span class="subst">$&#123; template &#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return output;</span></span><br><span class="line"><span class="string">  &#125;)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>compile函数的用法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parse = <span class="built_in">eval</span>(compile(template));</span><br><span class="line">div.innerHTML = parse(&#123; <span class="attr">supplies</span>: [ <span class="string">"broom"</span>, <span class="string">"mop"</span>, <span class="string">"cleaner"</span> ] &#125;);</span><br><span class="line"><span class="comment">//   &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;broom&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;mop&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;cleaner&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="7-表签模板"><a href="#7-表签模板" class="headerlink" title="7.表签模板"></a>7.表签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`hello`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert([<span class="string">'hello'</span>])</span><br></pre></td></tr></table></figure></p>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></p>
<p>tag函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]</li>
<li>第二个参数: 15</li>
<li>第三个参数：50<br>也就是说，tag函数实际上以下面的形式调用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// "Hello "</span></span><br><span class="line"><span class="comment">// " world "</span></span><br><span class="line"><span class="comment">// ""</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br><span class="line"><span class="comment">// "OK"</span></span><br></pre></td></tr></table></figure></p>
<p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line"><span class="comment">// "欢迎访问xxx，您是第xxxx位访问者！"</span></span><br></pre></td></tr></table></figure></p>
<p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    #end</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jsx<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      ref='input'</span></span><br><span class="line"><span class="string">      onChange='<span class="subst">$&#123;<span class="keyword">this</span>.handleChange&#125;</span>'</span></span><br><span class="line"><span class="string">      defaultValue='<span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span>' /&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">   &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p>
<h1 id="8。模板字符串的限制"><a href="#8。模板字符串的限制" class="headerlink" title="8。模板字符串的限制"></a>8。模板字符串的限制</h1><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p>
<p>举例来说，标签模板里面可以嵌入 LaTEX 语言。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">document</span> = latex<span class="string">`</span></span><br><span class="line"><span class="string">\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  // 正常工作</span></span><br><span class="line"><span class="string">\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错</span></span><br><span class="line"><span class="string">\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Breve over the h goes \u&#123;h&#125;ere // 报错</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p>
<p>模板字符串会将\u00FF和\u{42}当作 Unicode 字符进行转义，所以\unicode解析时报错；而\x56会被当作十六进制字符串转义，所以\xerxes会报错。也就是说，\u和\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。</p>
<p>为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  strs[<span class="number">0</span>] === <span class="literal">undefined</span></span><br><span class="line">  strs.raw[<span class="number">0</span>] === <span class="string">"\\unicode and \\u&#123;55&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">tag<span class="string">`\unicode and \u&#123;55&#125;`</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。</p>
<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bad = <span class="string">`bad escape sequence: \unicode`</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Q-Quiet.github.io/2020/02/05/es6-3-字符串的扩展/" data-id="cklg8rx9c00232cup3j7ct9rr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es6-2-变量的解构赋值" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/05/es6-2-变量的解构赋值/" class="article-date">
  <time datetime="2020-02-05T07:02:32.000Z" itemprop="datePublished">2020-02-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/05/es6-2-变量的解构赋值/">es6-2-变量的解构赋值</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="1-数组的解构赋值"><a href="#1-数组的解构赋值" class="headerlink" title="1.数组的解构赋值"></a>1.数组的解构赋值</h3><h6 id="ES6-允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为-解构"><a href="#ES6-允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为-解构" class="headerlink" title="ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为==解构=="></a>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为==解构==</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">ES6允许写成这样：</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h6 id="如果解构不成功，那么变量的值就等于undefined"><a href="#如果解构不成功，那么变量的值就等于undefined" class="headerlink" title="如果解构不成功，那么变量的值就等于undefined"></a>如果解构不成功，那么变量的值就等于<code>undefined</code></h6><h6 id="不完全解构"><a href="#不完全解构" class="headerlink" title="不完全解构"></a>不完全解构</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h6 id="解构赋值允许指定默认值"><a href="#解构赋值允许指定默认值" class="headerlink" title="解构赋值允许指定默认值"></a>解构赋值允许指定默认值</h6><p>但是：如果一个数组成员是<code>null</code>，那么默认值就不会生效，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h3><h5 id="对象的解构与数组有一个重要的不同。"><a href="#对象的解构与数组有一个重要的不同。" class="headerlink" title="对象的解构与数组有一个重要的不同。"></a>对象的解构与数组有一个重要的不同。</h5><h5 id="数组的元素是按次序排列的，变量的取值由它的位置决定；"><a href="#数组的元素是按次序排列的，变量的取值由它的位置决定；" class="headerlink" title="数组的元素是按次序排列的，变量的取值由它的位置决定；"></a>数组的元素是按次序排列的，变量的取值由它的位置决定；</h5><h5 id="而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。"><a href="#而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。" class="headerlink" title="而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。"></a>而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h5 id="与数组一样，解构也可以用于嵌套结构的对象"><a href="#与数组一样，解构也可以用于嵌套结构的对象" class="headerlink" title="与数组一样，解构也可以用于嵌套结构的对象"></a>与数组一样，解构也可以用于嵌套结构的对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;  <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line">注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。</span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></span><br></pre></td></tr></table></figure>
<h5 id="对象的解构也可以指定默认值"><a href="#对象的解构也可以指定默认值" class="headerlink" title="对象的解构也可以指定默认值"></a>对象的解构也可以指定默认值</h5><h5 id="注意点"><a href="#注意点" class="headerlink" title="==注意点=="></a>==注意点==</h5><ol>
<li><p>如果将一个已声明的变量用于解构赋值，必须非常小心</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p> 会报错是因为，js引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误<br> 正确写法<code>({x} = {x: 1});</code></p>
</li>
<li><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure>
<p> 虽然表达式无意义，但是语法是合法的</p>
</li>
<li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>此时，字符串被转换成了一个类似数组的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br></pre></td></tr></table></figure></p>
<p>还可以给length属性解构赋值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len<span class="comment">//5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>如果等号右边是数值和布尔值，则会先转为对象。（其实我没太懂）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x,y]</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>]);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>另一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<p>还有 undefined会触发函数参数的默认值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, 'yes', 3 ]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>不要在模式中设置圆括号</p>
<h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><ol>
<li><p>变量声明语句</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数<br>函数参数也属于变量声明，因此不能带有圆括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值语句的模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码将整个模式放在圆括号之中，导致报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure></p>
<h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>only one ：赋值语句的非模式部分，可以使用圆括号<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p>
<h3 id="变量的解构赋值用途"><a href="#变量的解构赋值用途" class="headerlink" title="变量的解构赋值用途"></a>变量的解构赋值用途</h3><h5 id="1）交换变量的值"><a href="#1）交换变量的值" class="headerlink" title="1）交换变量的值"></a>1）交换变量的值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x,y] = [y,x]</span><br></pre></td></tr></table></figure>
<h5 id="2）从函数返回多个值"><a href="#2）从函数返回多个值" class="headerlink" title="2）从函数返回多个值"></a>2）从函数返回多个值</h5><p>函数只能返回一个值，如果要返回多个值，只有将他们放在==数组==或者==对象==中返回。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></p>
<h5 id="3）函数参数的定义"><a href="#3）函数参数的定义" class="headerlink" title="3）函数参数的定义"></a>3）函数参数的定义</h5><p>解构赋值可以方便地将一组参数与变量名对应起来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h5 id="4）提取-JSON-数据"><a href="#4）提取-JSON-数据" class="headerlink" title="4）提取 JSON 数据"></a>4）提取 JSON 数据</h5><p>解构赋值对提取 JSON 对象中的数据，尤其有用。  (虽然我还没学json）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br><span class="line">上面代码可以快速提取 <span class="built_in">JSON</span> 数据的值。</span><br></pre></td></tr></table></figure></p>
<h5 id="5）函数参数的默认值"><a href="#5）函数参数的默认值" class="headerlink" title="5）函数参数的默认值"></a>5）函数参数的默认值</h5><p>（keke,我也没学jQuery呢）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<h5 id="6）遍历-Map-结构"><a href="#6）遍历-Map-结构" class="headerlink" title="6）遍历 Map 结构"></a>6）遍历 Map 结构</h5><p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure></p>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7）输入模块的指定方法"><a href="#7）输入模块的指定方法" class="headerlink" title="7）输入模块的指定方法"></a>7）输入模块的指定方法</h5><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Q-Quiet.github.io/2020/02/05/es6-2-变量的解构赋值/" data-id="cklg8rx7e00052cuprhio52ym" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es6-1-let和const" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/06/es6-1-let和const/" class="article-date">
  <time datetime="2019-05-06T12:13:17.000Z" itemprop="datePublished">2019-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/06/es6-1-let和const/">es6-1-let和const</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><h5 id="1-let只能在let命令所在的代码块内有效。"><a href="#1-let只能在let命令所在的代码块内有效。" class="headerlink" title="1.let只能在let命令所在的代码块内有效。"></a>1.let只能在let命令所在的代码块内有效。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> a</span><br><span class="line"> b</span><br></pre></td></tr></table></figure>
<h6 id="结果显示：b：2；a不存在；"><a href="#结果显示：b：2；a不存在；" class="headerlink" title="结果显示：b：2；a不存在；"></a>结果显示：b：2；a不存在；</h6><h5 id="2-不存在变量提升，let一定要先声明再使用"><a href="#2-不存在变量提升，let一定要先声明再使用" class="headerlink" title="2.不存在变量提升，let一定要先声明再使用"></a>2.不存在变量提升，let一定要先声明再使用</h5><h5 id="3-暂时性死区：在这个代码块里存在let命令的话，那么他所声明的变量就不受外部的影响"><a href="#3-暂时性死区：在这个代码块里存在let命令的话，那么他所声明的变量就不受外部的影响" class="headerlink" title="3.暂时性死区：在这个代码块里存在let命令的话，那么他所声明的变量就不受外部的影响"></a>3.暂时性死区：在这个代码块里存在let命令的话，那么他所声明的变量就不受外部的影响</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	temp = <span class="string">'abc'</span>;  <span class="comment">//ReferenceError</span></span><br><span class="line">	<span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-不允许在相同作用域内重复声明"><a href="#4-不允许在相同作用域内重复声明" class="headerlink" title="4.不允许在相同作用域内重复声明"></a>4.不允许在相同作用域内重复声明</h5><h5 id="5-块级作用域及声明："><a href="#5-块级作用域及声明：" class="headerlink" title="5.块级作用域及声明："></a>5.块级作用域及声明：</h5><pre><code>- 允许在块级作用域内声明函数
- 函数声明会提升到全局作用域或函数作用域头部
- 函数声明会提升到所在块级作用域的头部
</code></pre><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h5 id="1-声明一个只读常量，一旦声明，则不可改变，一旦声明必须立刻初始化，不能留到以后赋值"><a href="#1-声明一个只读常量，一旦声明，则不可改变，一旦声明必须立刻初始化，不能留到以后赋值" class="headerlink" title="1.声明一个只读常量，一旦声明，则不可改变，一旦声明必须立刻初始化，不能留到以后赋值"></a>1.声明一个只读常量，一旦声明，则不可改变，一旦声明必须立刻初始化，不能留到以后赋值</h5><h5 id="2-与let相同：只能在声明的块级作用域内有效"><a href="#2-与let相同：只能在声明的块级作用域内有效" class="headerlink" title="2.与let相同：只能在声明的块级作用域内有效"></a>2.与let相同：只能在声明的块级作用域内有效</h5><h5 id="3-存在暂时性死区"><a href="#3-存在暂时性死区" class="headerlink" title="3.存在暂时性死区"></a>3.存在暂时性死区</h5><h5 id="4-不可重复声明"><a href="#4-不可重复声明" class="headerlink" title="4.不可重复声明"></a>4.不可重复声明</h5><h5 id="5-可以使用-Object-freeze的方法将对象冻结const-foo-Object-freeze-这样就无法给foo对象里加东西了"><a href="#5-可以使用-Object-freeze的方法将对象冻结const-foo-Object-freeze-这样就无法给foo对象里加东西了" class="headerlink" title="5.可以使用 Object.freeze的方法将对象冻结const foo = Object.freeze({});这样就无法给foo对象里加东西了"></a>5.可以使用 Object.freeze的方法将对象冻结<code>const foo = Object.freeze({});</code>这样就无法给foo对象里加东西了</h5><h4 id="es6有六种声明方式"><a href="#es6有六种声明方式" class="headerlink" title="==es6有六种声明方式=="></a>==es6有六种声明方式==</h4><ul>
<li>var</li>
<li>function</li>
<li>let</li>
<li>const</li>
<li>import</li>
<li>class<blockquote>
<p>var命令和function命令声明的全局变量，依旧是顶层对象的属性<br>另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="globalThis-对象-这段不是完全明白：借鉴阮一峰的es6）"><a href="#globalThis-对象-这段不是完全明白：借鉴阮一峰的es6）" class="headerlink" title="globalThis 对象(这段不是完全明白：借鉴阮一峰的es6）"></a>globalThis 对象(这段不是完全明白：借鉴阮一峰的es6）</h4><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p>
<ul>
<li><ul>
<li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li>
<li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li>
<li>Node 里面，顶层对象是global，但其他环境都不支持。</li>
</ul>
</li>
</ul>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p>
<ul>
<li><ul>
<li>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Q-Quiet.github.io/2019/05/06/es6-1-let和const/" data-id="cklg8rx7g00082cupj2trh2d4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/05/hello-world/" class="article-date">
  <time datetime="2019-05-05T11:52:57.449Z" itemprop="datePublished">2019-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/05/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Q-Quiet.github.io/2019/05/05/hello-world/" data-id="cklg8rx7j00092cupqrsjihrx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ts/">ts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复习/">复习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/es6/" style="font-size: 17.5px;">es6</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/ts/" style="font-size: 15px;">ts</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/复习/" style="font-size: 12.5px;">复习</a> <a href="/tags/浏览器/" style="font-size: 15px;">浏览器</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/22/js-for-in-for-of/">js-for..in/for..of</a>
          </li>
        
          <li>
            <a href="/2021/01/31/ts-进阶-枚举/">ts-进阶-枚举</a>
          </li>
        
          <li>
            <a href="/2021/01/29/ts-基础-类型断言/">ts-基础-类型断言</a>
          </li>
        
          <li>
            <a href="/2021/01/29/ts-基础-函数的类型/">ts-基础-函数的类型</a>
          </li>
        
          <li>
            <a href="/2021/01/28/ts-基础-原始数据类型/">ts-基础-原始数据类型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Q-Quiet<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>