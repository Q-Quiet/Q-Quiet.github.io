<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>es6-5-正则的扩展 | Q-Quiet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.RegExp 构造函数在 ES5 中，RegExp构造函数的参数有两种情况。第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。123var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);// 等价于var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。123var regex = new RegExp(/xyz/">
<meta name="keywords" content="es6">
<meta property="og:type" content="article">
<meta property="og:title" content="es6-5-正则的扩展">
<meta property="og:url" content="https://Q-Quiet.github.io/2020/02/07/es6-5-正则的扩展/index.html">
<meta property="og:site_name" content="Q-Quiet">
<meta property="og:description" content="1.RegExp 构造函数在 ES5 中，RegExp构造函数的参数有两种情况。第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。123var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);// 等价于var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。123var regex = new RegExp(/xyz/">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-10-21T12:01:39.180Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="es6-5-正则的扩展">
<meta name="twitter:description" content="1.RegExp 构造函数在 ES5 中，RegExp构造函数的参数有两种情况。第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。123var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;);// 等价于var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。123var regex = new RegExp(/xyz/">
  
    <link rel="alternate" href="/atom.xml" title="Q-Quiet" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="shortcut icon" href="ban.jpeg" type="image/x-icon">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Q-Quiet</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">言语笑靥迎来情</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Q-Quiet.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-es6-5-正则的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/07/es6-5-正则的扩展/" class="article-date">
  <time datetime="2020-02-07T13:11:15.000Z" itemprop="datePublished">2020-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      es6-5-正则的扩展
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-RegExp-构造函数"><a href="#1-RegExp-构造函数" class="headerlink" title="1.RegExp 构造函数"></a>1.RegExp 构造函数</h1><h3 id="在-ES5-中，RegExp构造函数的参数有两种情况。"><a href="#在-ES5-中，RegExp构造函数的参数有两种情况。" class="headerlink" title="在 ES5 中，RegExp构造函数的参数有两种情况。"></a>在 ES5 中，RegExp构造函数的参数有两种情况。</h3><h3 id="第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。"><a href="#第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。" class="headerlink" title="第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。"></a>第一种：参数是字符串，这是第二个参数为正则表达式的修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<h3 id="第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。"><a href="#第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。" class="headerlink" title="第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。"></a>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<h3 id="但是，ES5-不允许此时使用第二个参数添加修饰符，否则会报错。"><a href="#但是，ES5-不允许此时使用第二个参数添加修饰符，否则会报错。" class="headerlink" title="但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。"></a>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure>
<h3 id="ES6-改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。"><a href="#ES6-改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。" class="headerlink" title="ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。"></a>ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags</span><br><span class="line"><span class="comment">// "i"</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。"><a href="#上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。" class="headerlink" title="上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。"></a>上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。</h3><hr>
<h1 id="2-字符串的正则方法"><a href="#2-字符串的正则方法" class="headerlink" title="2.字符串的正则方法"></a>2.字符串的正则方法</h1><h3 id="字符串对象共有-4-个方法，可以使用正则表达式：match-、replace-、search-和split-。"><a href="#字符串对象共有-4-个方法，可以使用正则表达式：match-、replace-、search-和split-。" class="headerlink" title="字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。"></a>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。</h3><h3 id="ES6-将这-4-个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。"><a href="#ES6-将这-4-个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。" class="headerlink" title="ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。"></a>ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</h3><blockquote>
<ul>
<li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
</ul>
</blockquote>
<h1 id="3-u-修饰符"><a href="#3-u-修饰符" class="headerlink" title="3.u 修饰符"></a>3.u 修饰符</h1><h3 id="ES6-对正则表达式添加了u修饰符，含义为“Unicode-模式”，用来正确处理大于-uFFFF的-Unicode-字符。也就是说，会正确处理四个字节的-UTF-16-编码。"><a href="#ES6-对正则表达式添加了u修饰符，含义为“Unicode-模式”，用来正确处理大于-uFFFF的-Unicode-字符。也就是说，会正确处理四个字节的-UTF-16-编码。" class="headerlink" title="ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。"></a>ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，-uD83D-uDC2A是一个四个字节的-UTF-16-编码，代表一个字符。但是，ES5-不支持四个字节的-UTF-16-编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6-就会识别其为一个字符，所以第一行代码结果为false。"><a href="#上面代码中，-uD83D-uDC2A是一个四个字节的-UTF-16-编码，代表一个字符。但是，ES5-不支持四个字节的-UTF-16-编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6-就会识别其为一个字符，所以第一行代码结果为false。" class="headerlink" title="上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。"></a>上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。</h3><h3 id="一旦加上u修饰符号，就会修改下面这些正则表达式的行为。"><a href="#一旦加上u修饰符号，就会修改下面这些正则表达式的行为。" class="headerlink" title="一旦加上u修饰符号，就会修改下面这些正则表达式的行为。"></a>一旦加上u修饰符号，就会修改下面这些正则表达式的行为。</h3><blockquote>
<p>（1）点字符</p>
</blockquote>
<h3 id="点（-）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的-Unicode-字符，点字符不能识别，必须加上u修饰符。"><a href="#点（-）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的-Unicode-字符，点字符不能识别，必须加上u修饰符。" class="headerlink" title="点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。"></a>点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span>;</span><br><span class="line"></span><br><span class="line">/^.$/.test(s) <span class="comment">// flase</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。"><a href="#上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。" class="headerlink" title="上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。"></a>上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</h3><blockquote>
<p>（2）Unicode 字符表示法</p>
</blockquote>
<h3 id="ES6-新增了使用大括号表示-Unicode-字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。"><a href="#ES6-新增了使用大括号表示-Unicode-字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。" class="headerlink" title="ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。"></a>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line">/\u&#123;<span class="number">20</span>BB7&#125;/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码表示，如果不加u修饰符，正则表达式无法识别-u-61-这种表示法，只会认为这匹配-61-个连续的u。"><a href="#上面代码表示，如果不加u修饰符，正则表达式无法识别-u-61-这种表示法，只会认为这匹配-61-个连续的u。" class="headerlink" title="上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的u。"></a>上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的u。</h3><blockquote>
<p>（3）量词</p>
</blockquote>
<h3 id="使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的-Unicode-字符。"><a href="#使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的-Unicode-字符。" class="headerlink" title="使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。"></a>使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/a&#123;<span class="number">2</span>&#125;/.test(<span class="string">'aa'</span>) <span class="comment">// true</span></span><br><span class="line">/a&#123;<span class="number">2</span>&#125;/u.test(<span class="string">'aa'</span>) <span class="comment">// true</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// false</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/u.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>（4）预定义模式</p>
</blockquote>
<h3 id="u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的-Unicode-字符。"><a href="#u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的-Unicode-字符。" class="headerlink" title="u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。"></a>u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\S$/.test(<span class="string">'𠮷'</span>) <span class="comment">// false</span></span><br><span class="line">/^\S$/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码的-S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的-Unicode-字符。"><a href="#上面代码的-S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的-Unicode-字符。" class="headerlink" title="上面代码的\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。"></a>上面代码的\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。</h3><h3 id="利用这一点，可以写出一个正确返回字符串长度的函数。"><a href="#利用这一点，可以写出一个正确返回字符串长度的函数。" class="headerlink" title="利用这一点，可以写出一个正确返回字符串长度的函数。"></a>利用这一点，可以写出一个正确返回字符串长度的函数。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line">  <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷𠮷'</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 4</span></span><br><span class="line">codePointLength(s) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>（5）i 修饰符</p>
</blockquote>
<h3 id="有些-Unicode-字符的编码不同，但是字型很相近，比如，-u004B与-u212A都是大写的K。"><a href="#有些-Unicode-字符的编码不同，但是字型很相近，比如，-u004B与-u212A都是大写的K。" class="headerlink" title="有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。"></a>有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[a-z]/i.test(<span class="string">'\u212A'</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">'\u212A'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，不加u修饰符，就无法识别非规范的K字符。"><a href="#上面代码中，不加u修饰符，就无法识别非规范的K字符。" class="headerlink" title="上面代码中，不加u修饰符，就无法识别非规范的K字符。"></a>上面代码中，不加u修饰符，就无法识别非规范的K字符。</h3><blockquote>
<p>（6）转义</p>
</blockquote>
<h3 id="没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义-）无效，而在u模式会报错。"><a href="#没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义-）无效，而在u模式会报错。" class="headerlink" title="没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\,）无效，而在u模式会报错。"></a>没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\,）无效，而在u模式会报错。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\,/ <span class="comment">// /\,/</span></span><br><span class="line">/\,/u <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。"><a href="#上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。" class="headerlink" title="上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。"></a>上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。</h3><hr>
<h1 id="4-RegExp-prototype-unicode-属性"><a href="#4-RegExp-prototype-unicode-属性" class="headerlink" title="4.RegExp.prototype.unicode 属性"></a>4.RegExp.prototype.unicode 属性</h1><h3 id="正则实例对象新增unicode属性，表示是否设置了u修饰符。"><a href="#正则实例对象新增unicode属性，表示是否设置了u修饰符。" class="headerlink" title="正则实例对象新增unicode属性，表示是否设置了u修饰符。"></a>正则实例对象新增unicode属性，表示是否设置了u修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">r1.unicode <span class="comment">// false</span></span><br><span class="line">r2.unicode <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。"><a href="#上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。" class="headerlink" title="上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。"></a>上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。</h3><hr>
<h1 id="5-y-修饰符"><a href="#5-y-修饰符" class="headerlink" title="5.y 修饰符"></a>5.y 修饰符</h1><h3 id="除了u修饰符，ES6-还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。"><a href="#除了u修饰符，ES6-还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。" class="headerlink" title="除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。"></a>除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</h3><h3 id="y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。"><a href="#y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。" class="headerlink" title="y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。"></a>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="第一次执行的时候，两者行为相同，剩余字符串都是-aa-a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。"><a href="#第一次执行的时候，两者行为相同，剩余字符串都是-aa-a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。" class="headerlink" title="第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。"></a>第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。</h3><h3 id="如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。"><a href="#如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。" class="headerlink" title="如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。"></a>如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a+_/y</span>;</span><br><span class="line"></span><br><span class="line">r.exec(s) <span class="comment">// ["aaa_"]</span></span><br><span class="line">r.exec(s) <span class="comment">// ["aa_"]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码每次匹配，都是从剩余字符串的头部开始。"><a href="#上面代码每次匹配，都是从剩余字符串的头部开始。" class="headerlink" title="上面代码每次匹配，都是从剩余字符串的头部开始。"></a>上面代码每次匹配，都是从剩余字符串的头部开始。</h3><h3 id="使用lastIndex属性，可以更好地说明y修饰符。"><a href="#使用lastIndex属性，可以更好地说明y修饰符。" class="headerlink" title="使用lastIndex属性，可以更好地说明y修饰符。"></a>使用lastIndex属性，可以更好地说明y修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">'xaya'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在3号位置匹配成功</span></span><br><span class="line">match.index <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4号位开始匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">'xaya'</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。"><a href="#上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。" class="headerlink" title="上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。"></a>上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。</h3><h3 id="y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。"><a href="#y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。" class="headerlink" title="y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。"></a>y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/y</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">'xaya'</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">'xaya'</span>);</span><br><span class="line">match.index <span class="comment">// 3</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h3 id="实际上，y修饰符号隐含了头部匹配的标志-。"><a href="#实际上，y修饰符号隐含了头部匹配的标志-。" class="headerlink" title="实际上，y修饰符号隐含了头部匹配的标志^。"></a>实际上，y修饰符号隐含了头部匹配的标志^。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/b/y.exec(<span class="string">'aba'</span>)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志-在全局匹配中都有效。"><a href="#上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志-在全局匹配中都有效。" class="headerlink" title="上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。"></a>上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</h3><p>???????????↑</p>
<h3 id="下面是字符串对象的replace方法的例子。"><a href="#下面是字符串对象的replace方法的例子。" class="headerlink" title="下面是字符串对象的replace方法的例子。"></a>下面是字符串对象的replace方法的例子。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/gy</span>;</span><br><span class="line"><span class="string">'aaxa'</span>.replace(REGEX, <span class="string">'-'</span>) <span class="comment">// '--xa'</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。"><a href="#上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。" class="headerlink" title="上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。"></a>上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。</h3><h3 id="单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。"><a href="#单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。" class="headerlink" title="单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。"></a>单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/y</span>) <span class="comment">// ["a1"]</span></span><br><span class="line"><span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/gy</span>) <span class="comment">// ["a1", "a2", "a3"]</span></span><br></pre></td></tr></table></figure>
<h3 id="y修饰符的一个应用，是从字符串提取-token（词元），y修饰符确保了匹配之间不会有漏掉的字符。"><a href="#y修饰符的一个应用，是从字符串提取-token（词元），y修饰符确保了匹配之间不会有漏掉的字符。" class="headerlink" title="y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。"></a>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TOKEN_Y = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line"><span class="keyword">const</span> TOKEN_G  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">'3 + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3 + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> (match = TOKEN_REGEX.exec(str)) &#123;</span><br><span class="line">    result.push(match[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。"><a href="#上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。" class="headerlink" title="上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。"></a>上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tokenize(TOKEN_Y, <span class="string">'3x + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3' ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3x + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。"><a href="#上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。" class="headerlink" title="上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。"></a>上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。</h3><h1 id="6-RegExp-prototype-sticky-属性"><a href="#6-RegExp-prototype-sticky-属性" class="headerlink" title="6.RegExp.prototype.sticky 属性"></a>6.RegExp.prototype.sticky 属性</h1><h3 id="与y修饰符相匹配，ES6-的正则实例对象多了sticky属性，表示是否设置了y修饰符。"><a href="#与y修饰符相匹配，ES6-的正则实例对象多了sticky属性，表示是否设置了y修饰符。" class="headerlink" title="与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。"></a>与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<hr>
<ol start="7">
<li>RegExp.prototype.flags 属性<h3 id="ES6-为正则表达式新增了flags属性，会返回正则表达式的修饰符。"><a href="#ES6-为正则表达式新增了flags属性，会返回正则表达式的修饰符。" class="headerlink" title="ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。"></a>ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的 source 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">/abc/ig.source</span><br><span class="line"><span class="comment">// "abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的 flags 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">/abc/ig.flags</span><br><span class="line"><span class="comment">// 'gi'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="8-s-修饰符：dotAll-模式"><a href="#8-s-修饰符：dotAll-模式" class="headerlink" title="8.s 修饰符：dotAll 模式"></a>8.s 修饰符：dotAll 模式</h1><h3 id="正则表达式中，点（-）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的-UTF-16-字符，这个可以用u修饰符解决；另一个是行终止符（line-terminator-character）。"><a href="#正则表达式中，点（-）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的-UTF-16-字符，这个可以用u修饰符解决；另一个是行终止符（line-terminator-character）。" class="headerlink" title="正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。"></a>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。</h3><h3 id="所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。"><a href="#所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。" class="headerlink" title="所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。"></a>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</h3><blockquote>
<p>U+000A 换行符（\n）<br>U+000D 回车符（\r）<br>U+2028 行分隔符（line separator）<br>U+2029 段分隔符（paragraph separator）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/.test(<span class="string">'foo\nbar'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="上面代码中，因为-不匹配-n，所以正则表达式返回false。"><a href="#上面代码中，因为-不匹配-n，所以正则表达式返回false。" class="headerlink" title="上面代码中，因为.不匹配\n，所以正则表达式返回false。"></a>上面代码中，因为.不匹配\n，所以正则表达式返回false。</h3><h3 id="但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。"><a href="#但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。" class="headerlink" title="但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。"></a>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo[^]bar/.test(<span class="string">'foo\nbar'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="这种解决方案毕竟不太符合直觉，ES2018-引入s修饰符，使得-可以匹配任意单个字符。"><a href="#这种解决方案毕竟不太符合直觉，ES2018-引入s修饰符，使得-可以匹配任意单个字符。" class="headerlink" title="这种解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。"></a>这种解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">'foo\nbar'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。"><a href="#这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。" class="headerlink" title="这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。"></a>这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="comment">// const re = new RegExp('foo.bar', 's');</span></span><br><span class="line"></span><br><span class="line">re.test(<span class="string">'foo\nbar'</span>) <span class="comment">// true</span></span><br><span class="line">re.dotAll <span class="comment">// true</span></span><br><span class="line">re.flags <span class="comment">// 's'</span></span><br></pre></td></tr></table></figure>
<h3 id="s修饰符和多行修饰符-m不冲突，两者一起使用的情况下，-匹配所有字符，而-和-匹配每一行的行首和行尾。"><a href="#s修饰符和多行修饰符-m不冲突，两者一起使用的情况下，-匹配所有字符，而-和-匹配每一行的行首和行尾。" class="headerlink" title="/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。"></a>/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。</h3><hr>
<h1 id="9-后行断言"><a href="#9-后行断言" class="headerlink" title="9.后行断言"></a>9.后行断言</h1><h3 id="JavaScript-语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative-lookahead），不支持后行断言（lookbehind）和后行否定断言（negative-lookbehind）。ES2018-引入后行断言，V8-引擎-4-9-版（Chrome-62）已经支持。"><a href="#JavaScript-语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative-lookahead），不支持后行断言（lookbehind）和后行否定断言（negative-lookbehind）。ES2018-引入后行断言，V8-引擎-4-9-版（Chrome-62）已经支持。" class="headerlink" title="JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。"></a>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。</h3><h3 id="“先行断言”指的是，x只有在y前面才匹配，必须写成-x-y-。比如，只匹配百分号之前的数字，要写成-d-。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成-x-y-。比如，只匹配不在百分号之前的数字，要写成-d-。"><a href="#“先行断言”指的是，x只有在y前面才匹配，必须写成-x-y-。比如，只匹配百分号之前的数字，要写成-d-。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成-x-y-。比如，只匹配不在百分号之前的数字，要写成-d-。" class="headerlink" title="“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。"></a>“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?=%)/.exec(<span class="string">'100% of US presidents have been male'</span>)  <span class="comment">// ["100"]</span></span><br><span class="line">/\d+(?!%)/.exec(<span class="string">'that’s all 44 of them'</span>)                 <span class="comment">// ["44"]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（-），是不计入返回结果的。"><a href="#上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（-），是不计入返回结果的。" class="headerlink" title="上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。"></a>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。</h3><h3 id="“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成-lt-y-x-。比如，只匹配美元符号之后的数字，要写成-lt-d-。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成-lt-y-x-。比如，只匹配不在美元符号后面的数字，要写成-lt-d-。"><a href="#“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成-lt-y-x-。比如，只匹配美元符号之后的数字，要写成-lt-d-。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成-lt-y-x-。比如，只匹配不在美元符号后面的数字，要写成-lt-d-。" class="headerlink" title="“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。"></a>“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=\$)\d+</span>/<span class="attr">.exec</span>('<span class="attr">Benjamin</span> <span class="attr">Franklin</span> <span class="attr">is</span> <span class="attr">on</span> <span class="attr">the</span> $<span class="attr">100</span> <span class="attr">bill</span>')  // ["<span class="attr">100</span>"]</span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">!\$)\d+</span>/<span class="attr">.exec</span>('<span class="attr">it</span>’<span class="attr">s</span> <span class="attr">is</span> <span class="attr">worth</span> <span class="attr">about</span> €<span class="attr">90</span>')                // ["<span class="attr">90</span>"]</span></span></span><br></pre></td></tr></table></figure>
<h3 id="上面的例子中，“后行断言”的括号之中的部分（-lt-），也是不计入返回结果。"><a href="#上面的例子中，“后行断言”的括号之中的部分（-lt-），也是不计入返回结果。" class="headerlink" title="上面的例子中，“后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。"></a>上面的例子中，“后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。</h3><h3 id="下面的例子是使用后行断言进行字符串替换。"><a href="#下面的例子是使用后行断言进行字符串替换。" class="headerlink" title="下面的例子是使用后行断言进行字符串替换。"></a>下面的例子是使用后行断言进行字符串替换。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DOLLAR_PREFIX = <span class="regexp">/(?&lt;=\$)foo/g</span>;</span><br><span class="line"><span class="string">'$foo %foo foo'</span>.replace(RE_DOLLAR_PREFIX, <span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// '$bar %foo foo'</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，只有在美元符号后面的foo才会被替换。"><a href="#上面代码中，只有在美元符号后面的foo才会被替换。" class="headerlink" title="上面代码中，只有在美元符号后面的foo才会被替换。"></a>上面代码中，只有在美元符号后面的foo才会被替换。</h3><h3 id="“后行断言”的实现，需要先匹配-lt-y-x-的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。"><a href="#“后行断言”的实现，需要先匹配-lt-y-x-的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。" class="headerlink" title="“后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。"></a>“后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</h3><h3 id="首先，后行断言的组匹配，与正常情况下结果是不一样的。"><a href="#首先，后行断言的组匹配，与正常情况下结果是不一样的。" class="headerlink" title="首先，后行断言的组匹配，与正常情况下结果是不一样的。"></a>首先，后行断言的组匹配，与正常情况下结果是不一样的。</h3><blockquote>
<p>下面的这个！！！不懂呀！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=(\d+)(\d+))$</span>/<span class="attr">.exec</span>('<span class="attr">1053</span>') // ["", "<span class="attr">1</span>", "<span class="attr">053</span>"]</span></span></span><br><span class="line"><span class="xml">/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"]</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。"><a href="#上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。" class="headerlink" title="上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。"></a>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。</h3><h3 id="其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。"><a href="#其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。" class="headerlink" title="其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。"></a>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=(o)d\1)r</span>/<span class="attr">.exec</span>('<span class="attr">hodor</span>')  // <span class="attr">null</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">=\1d(o))r</span>/<span class="attr">.exec</span>('<span class="attr">hodor</span>')  // ["<span class="attr">r</span>", "<span class="attr">o</span>"]</span></span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，如果后行断言的反斜杠引用（-1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。"><a href="#上面代码中，如果后行断言的反斜杠引用（-1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。" class="headerlink" title="上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。"></a>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</h3><h3 id="其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。-1"><a href="#其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。-1" class="headerlink" title="其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。"></a>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=(o)d\1)r</span>/<span class="attr">.exec</span>('<span class="attr">hodor</span>')  // <span class="attr">null</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">=\1d(o))r</span>/<span class="attr">.exec</span>('<span class="attr">hodor</span>')  // ["<span class="attr">r</span>", "<span class="attr">o</span>"]</span></span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，如果后行断言的反斜杠引用（-1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。-1"><a href="#上面代码中，如果后行断言的反斜杠引用（-1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。-1" class="headerlink" title="上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。"></a>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</h3><hr>
<h1 id="10-Unicode-属性类"><a href="#10-Unicode-属性类" class="headerlink" title="10.Unicode 属性类"></a>10.Unicode 属性类</h1><h3 id="ES2018-引入了一种新的类的写法-p-…-和-P-…-，允许正则表达式匹配符合-Unicode-某种属性的所有字符。"><a href="#ES2018-引入了一种新的类的写法-p-…-和-P-…-，允许正则表达式匹配符合-Unicode-某种属性的所有字符。" class="headerlink" title="ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。"></a>ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">regexGreekSymbol.test(<span class="string">'π'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，-p-Script-Greek-指定匹配一个希腊文字母，所以匹配π成功。"><a href="#上面代码中，-p-Script-Greek-指定匹配一个希腊文字母，所以匹配π成功。" class="headerlink" title="上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。"></a>上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。</h3><h3 id="Unicode-属性类要指定属性名和属性值。"><a href="#Unicode-属性类要指定属性名和属性值。" class="headerlink" title="Unicode 属性类要指定属性名和属性值。"></a>Unicode 属性类要指定属性名和属性值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName=UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对于某些属性，可以只写属性名，或者只写属性值。"><a href="#对于某些属性，可以只写属性名，或者只写属性值。" class="headerlink" title="对于某些属性，可以只写属性名，或者只写属性值。"></a>对于某些属性，可以只写属性名，或者只写属性值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName&#125;</span><br><span class="line">\p&#123;UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P-…-是-p-…-的反向匹配，即匹配不满足条件的字符。"><a href="#P-…-是-p-…-的反向匹配，即匹配不满足条件的字符。" class="headerlink" title="\P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。"></a>\P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。</h3><h3 id="注意，这两种类只对-Unicode-有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用-p和-P会报错，ECMAScript-预留了这两个类。"><a href="#注意，这两种类只对-Unicode-有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用-p和-P会报错，ECMAScript-预留了这两个类。" class="headerlink" title="注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。"></a>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。</h3><h3 id="由于-Unicode-的各种属性非常多，所以这种新的类的表达能力非常强。"><a href="#由于-Unicode-的各种属性非常多，所以这种新的类的表达能力非常强。" class="headerlink" title="由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。"></a>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Decimal_Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">'𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。"><a href="#上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。" class="headerlink" title="上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。"></a>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</h3><h3 id="p-Number-甚至能匹配罗马数字。"><a href="#p-Number-甚至能匹配罗马数字。" class="headerlink" title="\p{Number}甚至能匹配罗马数字。"></a>\p{Number}甚至能匹配罗马数字。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有数字</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">'²³¹¼½¾'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'㉛㉜㉝'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="下面是其他一些例子。"><a href="#下面是其他一些例子。" class="headerlink" title="下面是其他一些例子。"></a>下面是其他一些例子。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有空格</span></span><br><span class="line">\p&#123;White_Space&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 Emoji</span></span><br><span class="line">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line"><span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">regexArrows.test(<span class="string">'←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="11-具名组匹配"><a href="#11-具名组匹配" class="headerlink" title="11.具名组匹配"></a>11.具名组匹配</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="正则表达式使用圆括号进行组匹配。"><a href="#正则表达式使用圆括号进行组匹配。" class="headerlink" title="正则表达式使用圆括号进行组匹配。"></a>正则表达式使用圆括号进行组匹配。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。"><a href="#上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。" class="headerlink" title="上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。"></a>上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<h3 id="组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj-1-）引用，要是组的顺序变了，引用的时候就必须修改序号。"><a href="#组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj-1-）引用，要是组的顺序变了，引用的时候就必须修改序号。" class="headerlink" title="组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。"></a>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。</h3><h3 id="ES2018-引入了具名组匹配（Named-Capture-Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。"><a href="#ES2018-引入了具名组匹配（Named-Capture-Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。" class="headerlink" title="ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。"></a>ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号-尖括号-组名”（-），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj-1-）依然有效。"><a href="#上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号-尖括号-组名”（-），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj-1-）依然有效。" class="headerlink" title="上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。"></a>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?<year>），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。</year></h3><h3 id="具名组匹配等于为每一组匹配加上了-ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。"><a href="#具名组匹配等于为每一组匹配加上了-ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。" class="headerlink" title="具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。"></a>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</h3><h3 id="如果具名组没有匹配，那么对应的groups对象属性会是undefined。"><a href="#如果具名组没有匹配，那么对应的groups对象属性会是undefined。" class="headerlink" title="如果具名组没有匹配，那么对应的groups对象属性会是undefined。"></a>如果具名组没有匹配，那么对应的groups对象属性会是undefined。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_OPT_A = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_OPT_A.exec(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">matchObj.groups.as <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'as'</span> <span class="keyword">in</span> matchObj.groups <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，具名组as没有找到匹配，那么matchObj-groups-as属性值就是undefined，并且as这个键名在groups是始终存在的。"><a href="#上面代码中，具名组as没有找到匹配，那么matchObj-groups-as属性值就是undefined，并且as这个键名在groups是始终存在的。" class="headerlink" title="上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。"></a>上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。</h3><hr>
<h1 id="解构赋值和替换"><a href="#解构赋值和替换" class="headerlink" title="解构赋值和替换"></a>解构赋值和替换</h1><h3 id="有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。"><a href="#有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。" class="headerlink" title="有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。"></a>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class="string">'foo:bar'</span>);</span><br><span class="line">one  <span class="comment">// foo</span></span><br><span class="line">two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串替换时，使用-lt-组名-gt-引用具名组。"><a href="#字符串替换时，使用-lt-组名-gt-引用具名组。" class="headerlink" title="字符串替换时，使用$&lt;组名&gt;引用具名组。"></a>字符串替换时，使用$&lt;组名&gt;引用具名组。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">'2015-01-02'</span>.replace(re, <span class="string">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br><span class="line"><span class="comment">// '02/01/2015'</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。"><a href="#上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。" class="headerlink" title="上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。"></a>上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。</h3><h3 id="replace方法的第二个参数也可以是函数，该函数的参数序列如下。"><a href="#replace方法的第二个参数也可以是函数，该函数的参数序列如下。" class="headerlink" title="replace方法的第二个参数也可以是函数，该函数的参数序列如下。"></a>replace方法的第二个参数也可以是函数，该函数的参数序列如下。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'2015-01-02'</span>.replace(re, (</span><br><span class="line">   matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span><br><span class="line">   capture1, <span class="comment">// 第一个组匹配 2015</span></span><br><span class="line">   capture2, <span class="comment">// 第二个组匹配 01</span></span><br><span class="line">   capture3, <span class="comment">// 第三个组匹配 02</span></span><br><span class="line">   position, <span class="comment">// 匹配开始的位置 0</span></span><br><span class="line">   S, <span class="comment">// 原字符串 2015-01-02</span></span><br><span class="line">   groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span><br><span class="line"> ) =&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> &#123;day, month, year&#125; = groups;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;day&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。"><a href="#具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。" class="headerlink" title="具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。"></a>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</h3><hr>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h3 id="如果要在正则表达式内部引用某个“具名组匹配”，可以使用-k-lt-组名-gt-的写法。"><a href="#如果要在正则表达式内部引用某个“具名组匹配”，可以使用-k-lt-组名-gt-的写法。" class="headerlink" title="如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。"></a>如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="数字引用（-1）依然有效。"><a href="#数字引用（-1）依然有效。" class="headerlink" title="数字引用（\1）依然有效。"></a>数字引用（\1）依然有效。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="这两种引用语法还可以同时使用。"><a href="#这两种引用语法还可以同时使用。" class="headerlink" title="这两种引用语法还可以同时使用。"></a>这两种引用语法还可以同时使用。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="12-String-prototype-matchAll"><a href="#12-String-prototype-matchAll" class="headerlink" title="12.String.prototype.matchAll()"></a>12.String.prototype.matchAll()</h1><h3 id="如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。"><a href="#如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。" class="headerlink" title="如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。"></a>如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'test1test2test3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = [];</span><br><span class="line"><span class="keyword">var</span> match;</span><br><span class="line"><span class="keyword">while</span> (match = regex.exec(string)) &#123;</span><br><span class="line">  matches.push(match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matches</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"],</span></span><br><span class="line"><span class="comment">//   ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"],</span></span><br><span class="line"><span class="comment">//   ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，while循环取出每一轮的正则匹配，一共三轮。"><a href="#上面代码中，while循环取出每一轮的正则匹配，一共三轮。" class="headerlink" title="上面代码中，while循环取出每一轮的正则匹配，一共三轮。"></a>上面代码中，while循环取出每一轮的正则匹配，一共三轮。</h3><h3 id="ES2020-增加了String-prototype-matchAll-方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。"><a href="#ES2020-增加了String-prototype-matchAll-方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。" class="headerlink" title="ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。"></a>ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">'test1test2test3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g 修饰符加不加都可以</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.matchAll(regex)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]</span></span><br></pre></td></tr></table></figure>
<h3 id="上面代码中，由于string-matchAll-regex-返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。"><a href="#上面代码中，由于string-matchAll-regex-返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。" class="headerlink" title="上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。"></a>上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</h3><h3 id="遍历器转为数组是非常简单的，使用…运算符和Array-from-方法就可以了。"><a href="#遍历器转为数组是非常简单的，使用…运算符和Array-from-方法就可以了。" class="headerlink" title="遍历器转为数组是非常简单的，使用…运算符和Array.from()方法就可以了。"></a>遍历器转为数组是非常简单的，使用…运算符和Array.from()方法就可以了。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转为数组方法一</span></span><br><span class="line">[...string.matchAll(regex)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为数组方法二</span></span><br><span class="line"><span class="built_in">Array</span>.from(string.matchAll(regex))</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Q-Quiet.github.io/2020/02/07/es6-5-正则的扩展/" data-id="cklqizepr0038asup2jwwdojr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/02/10/es6-6-数值的扩展/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          es6-6-数值的扩展
        
      </div>
    </a>
  
  
    <a href="/2020/02/05/es6-4-字符串的新增方法/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">es6-4-字符串的新增方法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ts/">ts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/es6/" style="font-size: 17.5px;">es6</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/ts/" style="font-size: 12.5px;">ts</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/浏览器/" style="font-size: 15px;">浏览器</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/01/ES6-Promise/">ES6-Promise</a>
          </li>
        
          <li>
            <a href="/2021/03/01/ES6-Reflect/">ES6-Reflect</a>
          </li>
        
          <li>
            <a href="/2021/02/28/ES6-Proxy/">ES6-Proxy</a>
          </li>
        
          <li>
            <a href="/2021/02/28/ES6-解构赋值/">ES6-解构赋值</a>
          </li>
        
          <li>
            <a href="/2021/02/28/ES6-Set和Map/">ES6-Set和Map</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Q-Quiet<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>